@{
    ViewData["Title"] = "Vista de Realidad Aumentada";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GLTFLoader para cargar modelos 3D -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        #start-ar-button {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

            #start-ar-button:hover {
                background-color: #45a049;
                transform: translateX(-50%) scale(1.05);
            }

        #exit-ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            z-index: 2000;
            display: none;
        }

        #ar-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
        }

        #ar-status {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        /* Retículo para AR (ya no necesitamos este estilo CSS aquí, ya que usaremos Three.js para el retículo) */
        #distance-indicator {
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            z-index: 999;
            display: none;
        }

        #surface-quality {
            position: absolute;
            left: 50%;
            top: 70%;
            transform: translateX(-50%);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            z-index: 999;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <div id="ar-info">
            <div id="device-type">Detectando dispositivo...</div>
            <div id="mode-type">Modo: Cargando...</div>
        </div>

        <div id="ar-status">Mueve el dispositivo para detectar superficies</div>

        <button id="start-ar-button">Iniciar Realidad Aumentada</button>
        <button id="exit-ar-button" onclick="exitAR()">Salir</button>

        <div id="distance-indicator">Distancia: -- cm</div>
        <div id="surface-quality"></div>
    </div>

    <script>
        let scene, camera, renderer;
        let arSession = null;
        let arSupported = false;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let reticle;
        let cube;
        let isARActive = false;
        let isMobile = false;
        let productId = @ViewBag.ProductoId;
        let productName = '@ViewBag.ProductoNombre';

        // Detectar si es dispositivo móvil
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            document.getElementById('device-type').textContent = isMobile ? 'Dispositivo móvil detectado' : 'Dispositivo de escritorio detectado';

            // Verificar soporte WebXR
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    arSupported = supported;
                    document.getElementById('mode-type').textContent =
                        isMobile && arSupported ? 'Modo: AR disponible' :
                        isMobile ? 'Modo: Vista 3D (AR no disponible)' :
                        'Modo: Entorno 3D virtual';
                });
            } else {
                document.getElementById('mode-type').textContent =
                    isMobile ? 'Modo: Vista 3D' : 'Modo: Entorno 3D virtual';
            }
        }

        // Inicializar Three.js
        function initThreeJS() {
            scene = new THREE.Scene();

            // Configurar cámara
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 3);

            // Configurar renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;

            document.getElementById('ar-container').appendChild(renderer.domElement);

            // Crear el cubo rojo
            createRedCube();

            // Configurar iluminación
            setupLighting();

            // Si es escritorio, crear entorno virtual
            if (!isMobile) {
                createVirtualEnvironment();
            }

            // Crear retículo para AR
            createReticle();
        }

        // Crear cubo rojo
        function createRedCube() {
            const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                metalness: 0.1,
                roughness: 0.5
            });
            cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.visible = false; // Oculto inicialmente
            scene.add(cube);
        }

        // Configurar iluminación
        function setupLighting() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Luz direccional (simula el sol)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
        }

        // Crear entorno virtual para escritorio
        function createVirtualEnvironment() {
            // Cielo
            scene.background = new THREE.Color(0x87CEEB); // Azul cielo

            // Suelo
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a7b3c, // Verde césped
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Cuadrícula para mejor referencia visual
            const gridHelper = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Mostrar el cubo en escritorio
            cube.position.set(0, 0.5, 0);
            cube.visible = true;
        }

        // Crear retículo para AR
        function createReticle() {
            // Grupo para contener todos los elementos del retículo
            reticle = new THREE.Group();

            // Anillo principal
            const ringGeometry = new THREE.RingGeometry(0.05, 0.07, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            reticle.add(ring);

            // Anillo exterior pulsante
            const outerRingGeometry = new THREE.RingGeometry(0.08, 0.09, 32);
            const outerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            reticle.add(outerRing);

            // Líneas cruzadas
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });

            // Línea horizontal
            const horizontalPoints = [];
            horizontalPoints.push(new THREE.Vector3(-0.05, 0, 0));
            horizontalPoints.push(new THREE.Vector3(0.05, 0, 0));
            const horizontalGeometry = new THREE.BufferGeometry().setFromPoints(horizontalPoints);
            const horizontalLine = new THREE.Line(horizontalGeometry, lineMaterial);
            reticle.add(horizontalLine);

            // Línea vertical
            const verticalPoints = [];
            verticalPoints.push(new THREE.Vector3(0, -0.05, 0));
            verticalPoints.push(new THREE.Vector3(0, 0.05, 0));
            const verticalGeometry = new THREE.BufferGeometry().setFromPoints(verticalPoints);
            const verticalLine = new THREE.Line(verticalGeometry, lineMaterial);
            reticle.add(verticalLine);

            // Flecha indicadora de normal del plano
            const arrowGeometry = new THREE.ConeGeometry(0.02, 0.05, 16);
            const arrowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(0, 0, 0.08);
            arrow.rotation.x = Math.PI / 2;
            reticle.add(arrow);

            // Plano semitransparente para visualizar orientación
            const planeGeometry = new THREE.PlaneGeometry(0.15, 0.15);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            reticle.add(plane);

            // Cuadrícula para mostrar el plano detectado
            const gridHelper = new THREE.GridHelper(0.3, 5, 0xffffff, 0xffffff);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            gridHelper.position.set(0, -0.001, 0);  // Ligeramente por debajo del plano
            reticle.add(gridHelper);

            // Rotación inicial para que quede paralelo al suelo
            reticle.rotation.x = -Math.PI / 2;

            // Oculto inicialmente
            reticle.visible = false;

            // Añadir al escenario
            scene.add(reticle);

            // Animación de pulso para el anillo exterior
            function animatePulse() {
                const scale = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                outerRing.scale.set(scale, scale, 1);

                requestAnimationFrame(animatePulse);
            }
            animatePulse();
        }

        // Iniciar AR
        async function startAR() {
            if (!arSupported || !isMobile) {
                if (isMobile) {
                    // Vista 3D simple en móvil sin AR
                    startMobile3D();
                } else {
                    // Ya está funcionando el entorno 3D en escritorio
                    document.getElementById('start-ar-button').style.display = 'none';
                    document.getElementById('exit-ar-button').style.display = 'block';
                }
                return;
            }

            try {
                // Solicitar sesión AR
                arSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                renderer.xr.setReferenceSpaceType('local');
                await renderer.xr.setSession(arSession);

                // Configurar hit test
                arSession.addEventListener('select', onSelect);

                document.getElementById('start-ar-button').style.display = 'none';
                document.getElementById('exit-ar-button').style.display = 'block';
                document.getElementById('ar-status').style.display = 'block';

                isARActive = true;

                // Iniciar el loop de renderizado AR
                renderer.setAnimationLoop(render);

            } catch (error) {
                console.error('Error iniciando AR:', error);
                alert('No se pudo iniciar la realidad aumentada. Intenta de nuevo.');
            }
        }

        // Vista 3D para móvil sin AR
        function startMobile3D() {
            // Configurar controles táctiles simples
            let touchStart = null;

            renderer.domElement.addEventListener('touchstart', (e) => {
                touchStart = e.touches[0];
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!touchStart) return;

                const touchCurrent = e.touches[0];
                const deltaX = touchCurrent.pageX - touchStart.pageX;
                const deltaY = touchCurrent.pageY - touchStart.pageY;

                cube.rotation.y += deltaX * 0.01;
                cube.rotation.x += deltaY * 0.01;

                touchStart = touchCurrent;
            });

            // Mostrar el cubo
            cube.position.set(0, 0, -2);
            cube.visible = true;

            document.getElementById('start-ar-button').style.display = 'none';
            document.getElementById('exit-ar-button').style.display = 'block';

            animate();
        }

        // Manejador de selección en AR (cuando el usuario toca la pantalla)
        function onSelect() {
            if (reticle.visible && !cube.visible) {
                // Obtener la posición y orientación del retículo
                const position = new THREE.Vector3();
                const quaternion = new THREE.Quaternion();
                const scale = new THREE.Vector3();

                reticle.matrix.decompose(position, quaternion, scale);

                // Colocar el cubo en la posición del retículo con la misma orientación
                cube.position.copy(position);

                // Elevar ligeramente el cubo sobre la superficie
                cube.position.y += 0.15;

                // Si la superficie es vertical (ángulo cercano a 90 grados)
                const normalVector = new THREE.Vector3(0, 0, 1);
                normalVector.applyQuaternion(quaternion);
                const upVector = new THREE.Vector3(0, 1, 0);
                const angle = Math.acos(normalVector.dot(upVector)) * (180 / Math.PI);

                // Si la superficie es más vertical que horizontal
                if (angle > 45 && angle < 135) {
                    // Rotar el cubo para que se "pegue" a la pared
                    cube.quaternion.copy(quaternion);
                    // Y luego ajustar la posición para que esté justo frente a la superficie
                    const offset = new THREE.Vector3(0, 0, 0.15);
                    offset.applyQuaternion(quaternion);
                    cube.position.add(offset);
                }

                cube.visible = true;

                // Animación de aparición
                cube.scale.set(0.1, 0.1, 0.1);
                animateScale(cube, { x: 1, y: 1, z: 1 }, 300);

                // Ocultar indicadores
                document.getElementById('ar-status').textContent = 'Objeto colocado';
                setTimeout(() => {
                    document.getElementById('ar-status').style.display = 'none';
                    document.getElementById('distance-indicator').style.display = 'none';
                    document.getElementById('surface-quality').style.display = 'none';
                }, 2000);
            }
        }

        // Animación de escala
        function animateScale(object, targetScale, duration) {
            const startScale = {
                x: object.scale.x,
                y: object.scale.y,
                z: object.scale.z
            };
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                object.scale.x = startScale.x + (targetScale.x - startScale.x) * progress;
                object.scale.y = startScale.y + (targetScale.y - startScale.y) * progress;
                object.scale.z = startScale.z + (targetScale.z - startScale.z) * progress;

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            update();
        }

        // Loop de renderizado para AR
        function render(timestamp, frame) {
            if (frame && isARActive) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });

                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });

                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0 && !cube.visible) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);

                        // Obtener la posición y orientación del hit test
                        const position = pose.transform.position;
                        const orientation = pose.transform.orientation;

                        // Calcular distancia a la superficie
                        const distance = Math.sqrt(
                            position.x * position.x +
                            position.y * position.y +
                            position.z * position.z
                        );

                        // Mostrar indicador de distancia
                        const distanceEl = document.getElementById('distance-indicator');
                        distanceEl.style.display = 'block';
                        const distanceCm = (distance * 100).toFixed(0);
                        distanceEl.textContent = `Distancia: ${distanceCm} cm`;

                        // Evaluar calidad de la superficie
                        const surfaceQualityEl = document.getElementById('surface-quality');
                        surfaceQualityEl.style.display = 'block';

                        // Calidad basada en ángulo y distancia
                        let quality = 'buena';
                        let color = '#4CAF50'; // Verde por defecto

                        // Verificar si la superficie es más o menos horizontal
                        // Calculando el ángulo entre el vector normal de la superficie y el vector "hacia arriba"
                        const normalVector = new THREE.Vector3(0, 0, 1);
                        normalVector.applyQuaternion(new THREE.Quaternion(
                            orientation.x,
                            orientation.y,
                            orientation.z,
                            orientation.w
                        ));

                        const upVector = new THREE.Vector3(0, 1, 0);
                        const angle = Math.acos(normalVector.dot(upVector)) * (180 / Math.PI);

                        // Ajustar calidad según el ángulo (para superficies horizontales y verticales)
                        if ((angle < 20 || angle > 160) || (angle > 70 && angle < 110)) {
                            // Superficie horizontal o vertical (buena)
                            if (distance > 2) {
                                quality = 'demasiado lejos';
                                color = '#FFC107'; // Amarillo
                            }
                        } else {
                            // Superficie inclinada (menos ideal)
                            quality = 'inclinada';
                            color = '#FF9800'; // Naranja

                            if (distance > 1.5) {
                                quality = 'inclinada y lejos';
                                color = '#F44336'; // Rojo
                            }
                        }

                        surfaceQualityEl.textContent = `Superficie: ${quality}`;
                        surfaceQualityEl.style.backgroundColor = color;
                        surfaceQualityEl.style.color = 'white';

                        // Actualizar el retículo
                        reticle.visible = true;

                        // Aplicar la matriz de transformación completa al retículo
                        reticle.matrix.fromArray(pose.transform.matrix);
                        reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);

                        // Ajustar el tamaño basado en la distancia
                        const scaleFactor = Math.max(0.5, Math.min(1.5, distance));
                        reticle.scale.set(scaleFactor, scaleFactor, scaleFactor);

                        // Cambiar color según calidad
                        reticle.children.forEach(child => {
                            if (child.material && child.material.color) {
                                // El plano semitransparente (índice 4) cambia de color según calidad
                                if (child === reticle.children[4]) {
                                    child.material.color.set(color);
                                }
                            }
                        });
                    } else if (hitTestResults.length === 0) {
                        reticle.visible = false;
                        document.getElementById('distance-indicator').style.display = 'none';
                        document.getElementById('surface-quality').style.display = 'none';
                    }
                }
            }

            // Rotación del cubo
            if (cube.visible) {
                cube.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }

        // Loop de animación para entorno 3D (no AR)
        function animate() {
            requestAnimationFrame(animate);

            // Rotación del cubo
            if (cube.visible) {
                cube.rotation.y += 0.01;
                cube.rotation.x += 0.005;
            }

            renderer.render(scene, camera);
        }

        // Salir de AR
        function exitAR() {
            if (arSession) {
                arSession.end();
                arSession = null;
                isARActive = false;
            }

            // Volver a la página de detalle del producto
            window.location.href = '@Url.Action("Detalle", "Productos", new { id = ViewBag.ProductoId })';
        }

        // Manejar redimensionamiento de ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Event listener para el botón de inicio
        document.getElementById('start-ar-button').addEventListener('click', startAR);

        // Inicialización
        detectDevice();
        initThreeJS();

        // Si es escritorio, iniciar animación automáticamente
        if (!isMobile) {
            animate();
        }
    </script>
</body>
</html>