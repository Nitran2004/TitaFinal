@{
    ViewData["Title"] = "Vista de Realidad Aumentada";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GLTFLoader para cargar modelos 3D -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        #start-ar-button {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

            #start-ar-button:hover {
                background-color: #45a049;
                transform: translateX(-50%) scale(1.05);
            }

        #exit-ar-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            z-index: 2000;
            display: none;
        }

        #ar-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
        }

        #ar-status {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        /* Retículo para AR (ya no necesitamos este estilo CSS aquí, ya que usaremos Three.js para el retículo) */
        #distance-indicator {
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            z-index: 999;
            display: none;
        }

        #surface-quality {
            position: absolute;
            left: 50%;
            top: 70%;
            transform: translateX(-50%);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            z-index: 999;
            display: none;
        }

        #object-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 20px;
            font-size: 14px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        #gesture-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <div id="ar-info">
            <div id="device-type">Detectando dispositivo...</div>
            <div id="mode-type">Modo: Cargando...</div>
        </div>

        <div id="ar-status">Mueve el dispositivo para detectar superficies</div>

        <button id="start-ar-button">Iniciar Realidad Aumentada</button>
        <button id="exit-ar-button" onclick="exitAR()">Salir</button>

        <div id="distance-indicator">Distancia: -- cm</div>
        <div id="surface-quality"></div>
        <div id="object-controls">Arrastra para mover • Pellizca para acercar/alejar</div>
        <div id="gesture-indicator"></div>
    </div>

    <script>
        let scene, camera, renderer;
        let arSession = null;
        let arSupported = false;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let reticle;
        let cube;
        let isARActive = false;
        let isMobile = false;
        let productId = @ViewBag.ProductoId;
        let productName = '@ViewBag.ProductoNombre';

        // Variables para manipulación del objeto
        let isObjectPlaced = false;
        let isMovingObject = false;
        let isScalingObject = false;
        let lastTouchPosition = { x: 0, y: 0 };
        let initialTouchDistance = 0;
        let initialObjectDistance = 0;
        let objectPlane = new THREE.Plane();
        let movementIndicator;

        // Detectar si es dispositivo móvil
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            document.getElementById('device-type').textContent = isMobile ? 'Dispositivo móvil detectado' : 'Dispositivo de escritorio detectado';

            // Verificar soporte WebXR
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    arSupported = supported;
                    document.getElementById('mode-type').textContent =
                        isMobile && arSupported ? 'Modo: AR disponible' :
                        isMobile ? 'Modo: Vista 3D (AR no disponible)' :
                        'Modo: Entorno 3D virtual';
                });
            } else {
                document.getElementById('mode-type').textContent =
                    isMobile ? 'Modo: Vista 3D' : 'Modo: Entorno 3D virtual';
            }
        }

        // Inicializar Three.js
        function initThreeJS() {
            scene = new THREE.Scene();

            // Configurar cámara
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 3);

            // Configurar renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;

            document.getElementById('ar-container').appendChild(renderer.domElement);

            // Crear el cubo rojo
            createRedCube();

            // Configurar iluminación
            setupLighting();

            // Si es escritorio, crear entorno virtual
            if (!isMobile) {
                createVirtualEnvironment();
            }

            // Crear retículo para AR
            createReticle();

            // Crear indicador de movimiento
            createMovementIndicator();
        }

        // Crear indicador de movimiento
        function createMovementIndicator() {
            // Grupo para contener todos los elementos del indicador
            movementIndicator = new THREE.Group();

            // Crear anillo indicador
            const ringGeometry = new THREE.RingGeometry(0.2, 0.22, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            movementIndicator.add(ring);

            // Crear flechas direccionales (cuatro flechas)
            const arrowSize = 0.05;
            const arrowShape = new THREE.Shape();

            // Dibujar flecha
            arrowShape.moveTo(0, arrowSize * 2);
            arrowShape.lineTo(arrowSize, 0);
            arrowShape.lineTo(-arrowSize, 0);
            arrowShape.lineTo(0, arrowSize * 2);

            const arrowGeometry = new THREE.ShapeGeometry(arrowShape);
            const arrowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            // Flecha hacia arriba
            const arrowUp = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowUp.position.set(0, 0.28, 0);
            movementIndicator.add(arrowUp);

            // Flecha hacia abajo
            const arrowDown = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowDown.rotation.z = Math.PI;
            arrowDown.position.set(0, -0.28, 0);
            movementIndicator.add(arrowDown);

            // Flecha hacia la derecha
            const arrowRight = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowRight.rotation.z = -Math.PI / 2;
            arrowRight.position.set(0.28, 0, 0);
            movementIndicator.add(arrowRight);

            // Flecha hacia la izquierda
            const arrowLeft = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrowLeft.rotation.z = Math.PI / 2;
            arrowLeft.position.set(-0.28, 0, 0);
            movementIndicator.add(arrowLeft);

            // Círculo central
            const circleGeometry = new THREE.CircleGeometry(0.15, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            movementIndicator.add(circle);

            // Inicialmente invisible
            movementIndicator.visible = false;

            // Añadir al escenario
            scene.add(movementIndicator);

            // Animación pulsante
            function animatePulse() {
                if (movementIndicator.visible) {
                    const scale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                    ring.scale.set(scale, scale, 1);
                }
                requestAnimationFrame(animatePulse);
            }

            animatePulse();
        }

        // Crear cubo rojo
        function createRedCube() {
            const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                metalness: 0.1,
                roughness: 0.5
            });
            cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.visible = false; // Oculto inicialmente
            scene.add(cube);
        }

        // Configurar iluminación
        function setupLighting() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Luz direccional (simula el sol)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
        }

        // Crear entorno virtual para escritorio
        function createVirtualEnvironment() {
            // Cielo
            scene.background = new THREE.Color(0x87CEEB); // Azul cielo

            // Suelo
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a7b3c, // Verde césped
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Cuadrícula para mejor referencia visual
            const gridHelper = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Mostrar el cubo en escritorio
            cube.position.set(0, 0.5, 0);
            cube.visible = true;
        }

        // Crear retículo para AR
        function createReticle() {
            // Grupo para contener todos los elementos del retículo
            reticle = new THREE.Group();

            // Anillo principal
            const ringGeometry = new THREE.RingGeometry(0.05, 0.07, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            reticle.add(ring);

            // Anillo exterior pulsante
            const outerRingGeometry = new THREE.RingGeometry(0.08, 0.09, 32);
            const outerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            reticle.add(outerRing);

            // Líneas cruzadas
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });

            // Línea horizontal
            const horizontalPoints = [];
            horizontalPoints.push(new THREE.Vector3(-0.05, 0, 0));
            horizontalPoints.push(new THREE.Vector3(0.05, 0, 0));
            const horizontalGeometry = new THREE.BufferGeometry().setFromPoints(horizontalPoints);
            const horizontalLine = new THREE.Line(horizontalGeometry, lineMaterial);
            reticle.add(horizontalLine);

            // Línea vertical
            const verticalPoints = [];
            verticalPoints.push(new THREE.Vector3(0, -0.05, 0));
            verticalPoints.push(new THREE.Vector3(0, 0.05, 0));
            const verticalGeometry = new THREE.BufferGeometry().setFromPoints(verticalPoints);
            const verticalLine = new THREE.Line(verticalGeometry, lineMaterial);
            reticle.add(verticalLine);

            // Flecha indicadora de normal del plano
            const arrowGeometry = new THREE.ConeGeometry(0.02, 0.05, 16);
            const arrowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(0, 0, 0.08);
            arrow.rotation.x = Math.PI / 2;
            reticle.add(arrow);

            // Plano semitransparente para visualizar orientación
            const planeGeometry = new THREE.PlaneGeometry(0.15, 0.15);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            reticle.add(plane);

            // Cuadrícula para mostrar el plano detectado
            const gridHelper = new THREE.GridHelper(0.3, 5, 0xffffff, 0xffffff);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            gridHelper.position.set(0, -0.001, 0);  // Ligeramente por debajo del plano
            reticle.add(gridHelper);

            // Rotación inicial para que quede paralelo al suelo
            reticle.rotation.x = -Math.PI / 2;

            // Oculto inicialmente
            reticle.visible = false;

            // Añadir al escenario
            scene.add(reticle);

            // Animación de pulso para el anillo exterior
            function animatePulse() {
                const scale = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                outerRing.scale.set(scale, scale, 1);

                requestAnimationFrame(animatePulse);
            }
            animatePulse();
        }

        // Iniciar AR
        async function startAR() {
            if (!arSupported || !isMobile) {
                if (isMobile) {
                    // Vista 3D simple en móvil sin AR
                    startMobile3D();
                } else {
                    // Ya está funcionando el entorno 3D en escritorio
                    document.getElementById('start-ar-button').style.display = 'none';
                    document.getElementById('exit-ar-button').style.display = 'block';
                }
                return;
            }

            try {
                // Solicitar sesión AR
                arSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                renderer.xr.setReferenceSpaceType('local');
                await renderer.xr.setSession(arSession);

                // Configurar hit test
                arSession.addEventListener('select', onSelect);

                document.getElementById('start-ar-button').style.display = 'none';
                document.getElementById('exit-ar-button').style.display = 'block';
                document.getElementById('ar-status').style.display = 'block';

                isARActive = true;

                // Iniciar el loop de renderizado AR
                renderer.setAnimationLoop(render);

            } catch (error) {
                console.error('Error iniciando AR:', error);
                alert('No se pudo iniciar la realidad aumentada. Intenta de nuevo.');
            }
        }

        // Vista 3D para móvil sin AR
        function startMobile3D() {
            // Configurar controles táctiles simples
            let touchStart = null;

            renderer.domElement.addEventListener('touchstart', (e) => {
                touchStart = e.touches[0];
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!touchStart) return;

                const touchCurrent = e.touches[0];
                const deltaX = touchCurrent.pageX - touchStart.pageX;
                const deltaY = touchCurrent.pageY - touchStart.pageY;

                cube.rotation.y += deltaX * 0.01;
                cube.rotation.x += deltaY * 0.01;

                touchStart = touchCurrent;
            });

            // Mostrar el cubo
            cube.position.set(0, 0, -2);
            cube.visible = true;

            document.getElementById('start-ar-button').style.display = 'none';
            document.getElementById('exit-ar-button').style.display = 'block';

            animate();
        }

        // Manejador de selección en AR (cuando el usuario toca la pantalla)
        function onSelect() {
            if (reticle.visible && !cube.visible) {
                // Obtener la posición y orientación del retículo
                const position = new THREE.Vector3();
                const quaternion = new THREE.Quaternion();
                const scale = new THREE.Vector3();

                reticle.matrix.decompose(position, quaternion, scale);

                // Colocar el cubo en la posición del retículo con la misma orientación
                cube.position.copy(position);

                // Elevar ligeramente el cubo sobre la superficie
                cube.position.y += 0.15;

                // Si la superficie es vertical (ángulo cercano a 90 grados)
                const normalVector = new THREE.Vector3(0, 0, 1);
                normalVector.applyQuaternion(quaternion);
                const upVector = new THREE.Vector3(0, 1, 0);
                const angle = Math.acos(normalVector.dot(upVector)) * (180 / Math.PI);

                // Si la superficie es más vertical que horizontal
                if (angle > 45 && angle < 135) {
                    // Rotar el cubo para que se "pegue" a la pared
                    cube.quaternion.copy(quaternion);
                    // Y luego ajustar la posición para que esté justo frente a la superficie
                    const offset = new THREE.Vector3(0, 0, 0.15);
                    offset.applyQuaternion(quaternion);
                    cube.position.add(offset);
                }

                cube.visible = true;

                // Animación de aparición
                cube.scale.set(0.1, 0.1, 0.1);
                animateScale(cube, { x: 1, y: 1, z: 1 }, 300);

                // Guardar el plano en el que se colocó el objeto
                // Para cálculos futuros de movimiento
                objectPlane.setFromNormalAndCoplanarPoint(
                    normalVector,
                    cube.position
                );

                // Marcar que el objeto ha sido colocado
                isObjectPlaced = true;

                // Ocultar indicadores de AR
                document.getElementById('ar-status').textContent = 'Objeto colocado';
                document.getElementById('ar-status').style.display = 'none';
                document.getElementById('distance-indicator').style.display = 'none';
                document.getElementById('surface-quality').style.display = 'none';

                // Mostrar controles de objeto
                document.getElementById('object-controls').style.display = 'block';

                // Configurar eventos táctiles para manipulación
                setupObjectManipulation();
            }
        }

        // Configurar manipulación del objeto
        function setupObjectManipulation() {
            const canvas = renderer.domElement;

            // Evento de inicio de toque
            canvas.addEventListener('touchstart', onTouchStart, false);
            canvas.addEventListener('touchmove', onTouchMove, false);
            canvas.addEventListener('touchend', onTouchEnd, false);

            // Mostrar instrucciones de manipulación
            showGestureIndicator('👆');
            setTimeout(() => {
                showGestureIndicator('👋');
            }, 1500);
            setTimeout(() => {
                showGestureIndicator('👌');
            }, 3000);
        }

        // Mostrar indicador de gesto
        function showGestureIndicator(emoji) {
            const indicator = document.getElementById('gesture-indicator');
            indicator.textContent = emoji;
            indicator.style.opacity = '0.8';

            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 1000);
        }

        // Evento de inicio de toque
        function onTouchStart(event) {
            event.preventDefault();

            if (!isObjectPlaced || !cube.visible) return;

            // Verificar si es multitoque (escalar) o toque simple (mover)
            if (event.touches.length === 2) {
                // Dos dedos - escalar (zoom)
                isScalingObject = true;
                isMovingObject = false;

                // Calcular distancia inicial entre los dedos
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                initialTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                // Calcular tamaño inicial del objeto
                initialObjectDistance = cube.scale.x; // Asumiendo escala uniforme

                // Mostrar indicador de escala
                showGestureIndicator('↔️');

            } else if (event.touches.length === 1) {
                // Un dedo - mover
                isMovingObject = true;
                isScalingObject = false;

                // Guardar posición inicial del toque
                const touch = event.touches[0];
                lastTouchPosition.x = touch.clientX;
                lastTouchPosition.y = touch.clientY;

                // Posicionar y mostrar el indicador de movimiento
                updateMovementIndicator();

                // Mostrar indicador de movimiento
                showGestureIndicator('✋');
            }
        }

        // Actualizar indicador de movimiento
        function updateMovementIndicator() {
            if (!movementIndicator || !cube.visible) return;

            // Posicionar el indicador justo encima del cubo
            movementIndicator.position.copy(cube.position);
            movementIndicator.position.y += 0.3; // Elevarlo un poco sobre el cubo

            // Hacer el indicador visible y mirando a la cámara
            movementIndicator.visible = isMovingObject;
            movementIndicator.quaternion.copy(camera.quaternion);
        }

        // Evento de movimiento de toque
        function onTouchMove(event) {
            event.preventDefault();

            if (!isObjectPlaced || !cube.visible) return;

            // Si estamos escalando (dos dedos)
            if (isScalingObject && event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];

                // Calcular nueva distancia entre dedos
                const currentTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                // Calcular factor de escala
                const scaleFactor = currentTouchDistance / initialTouchDistance;

                // Aplicar nueva escala al objeto, limitando el tamaño
                const newScale = initialObjectDistance * scaleFactor;
                const clampedScale = Math.max(0.3, Math.min(2.0, newScale));
                cube.scale.set(clampedScale, clampedScale, clampedScale);

            // Si estamos moviendo (un dedo)
            } else if (isMovingObject && event.touches.length === 1) {
                const touch = event.touches[0];

                // Calcular el movimiento del dedo
                const deltaX = touch.clientX - lastTouchPosition.x;
                const deltaY = touch.clientY - lastTouchPosition.y;

                // Convertir movimiento de pantalla a movimiento 3D
                moveObjectOnPlane(deltaX, deltaY);

                // Actualizar última posición
                lastTouchPosition.x = touch.clientX;
                lastTouchPosition.y = touch.clientY;

                // Actualizar posición del indicador de movimiento
                updateMovementIndicator();
            }
        }

        // Mover objeto en el plano detectado
        function moveObjectOnPlane(deltaX, deltaY) {
            // Obtener el tamaño de la pantalla
            const width = renderer.domElement.clientWidth;
            const height = renderer.domElement.clientHeight;

            // Calcular dirección de movimiento relativa a la cámara
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

            // Ajustar la dirección 'up' para que sea paralela al plano
            up.projectOnPlane(objectPlane.normal).normalize();

            // Ajustar la dirección 'right' para que sea paralela al plano
            right.projectOnPlane(objectPlane.normal).normalize();

            // Calcular factor de sensibilidad basado en la distancia a la cámara
            const distance = camera.position.distanceTo(cube.position);
            const sensitivity = distance * 0.003;

            // Aplicar movimiento
            cube.position.add(right.multiplyScalar(deltaX * sensitivity));
            cube.position.add(up.multiplyScalar(-deltaY * sensitivity));

            // Asegurarse de que permanezca en el plano original
            const distanceToPlane = objectPlane.distanceToPoint(cube.position);
            if (Math.abs(distanceToPlane) > 0.01) {
                const correction = objectPlane.normal.clone().multiplyScalar(-distanceToPlane);
                cube.position.add(correction);
            }
        }

        // Evento de fin de toque
        function onTouchEnd(event) {
            event.preventDefault();

            // Restablecer estados
            isMovingObject = false;
            isScalingObject = false;

            // Ocultar indicador de movimiento
            if (movementIndicator) {
                movementIndicator.visible = false;
            }
        }

        // Animación de escala
        function animateScale(object, targetScale, duration) {
            const startScale = {
                x: object.scale.x,
                y: object.scale.y,
                z: object.scale.z
            };
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                object.scale.x = startScale.x + (targetScale.x - startScale.x) * progress;
                object.scale.y = startScale.y + (targetScale.y - startScale.y) * progress;
                object.scale.z = startScale.z + (targetScale.z - startScale.z) * progress;

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            update();
        }

        // Loop de renderizado para AR
        function render(timestamp, frame) {
            if (frame && isARActive) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!isObjectPlaced) {
                    // Si el objeto aún no ha sido colocado, seguir con el hit test
                    if (hitTestSourceRequested === false) {
                        session.requestReferenceSpace('viewer').then((referenceSpace) => {
                            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                                hitTestSource = source;
                            });
                        });

                        session.addEventListener('end', () => {
                            hitTestSourceRequested = false;
                            hitTestSource = null;
                        });

                        hitTestSourceRequested = true;
                    }

                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);

                        if (hitTestResults.length > 0 && !cube.visible) {
                            const hit = hitTestResults[0];
                            const pose = hit.getPose(referenceSpace);

                            // Obtener la posición y orientación del hit test
                            const position = pose.transform.position;
                            const orientation = pose.transform.orientation;

                            // Calcular distancia a la superficie
                            const distance = Math.sqrt(
                                position.x * position.x +
                                position.y * position.y +
                                position.z * position.z
                            );

                            // Mostrar indicador de distancia
                            const distanceEl = document.getElementById('distance-indicator');
                            distanceEl.style.display = 'block';
                            const distanceCm = (distance * 100).toFixed(0);
                            distanceEl.textContent = `Distancia: ${distanceCm} cm`;

                            // Evaluar calidad de la superficie
                            const surfaceQualityEl = document.getElementById('surface-quality');
                            surfaceQualityEl.style.display = 'block';

                            // Calidad basada en ángulo y distancia
                            let quality = 'buena';
                            let color = '#4CAF50'; // Verde por defecto

                            // Verificar si la superficie es más o menos horizontal
                            // Calculando el ángulo entre el vector normal de la superficie y el vector "hacia arriba"
                            const normalVector = new THREE.Vector3(0, 0, 1);
                            normalVector.applyQuaternion(new THREE.Quaternion(
                                orientation.x,
                                orientation.y,
                                orientation.z,
                                orientation.w
                            ));

                            const upVector = new THREE.Vector3(0, 1, 0);
                            const angle = Math.acos(normalVector.dot(upVector)) * (180 / Math.PI);

                            // Ajustar calidad según el ángulo (para superficies horizontales y verticales)
                            if ((angle < 20 || angle > 160) || (angle > 70 && angle < 110)) {
                                // Superficie horizontal o vertical (buena)
                                if (distance > 2) {
                                    quality = 'demasiado lejos';
                                    color = '#FFC107'; // Amarillo
                                }
                            } else {
                                // Superficie inclinada (menos ideal)
                                quality = 'inclinada';
                                color = '#FF9800'; // Naranja

                                if (distance > 1.5) {
                                    quality = 'inclinada y lejos';
                                    color = '#F44336'; // Rojo
                                }
                            }

                            surfaceQualityEl.textContent = `Superficie: ${quality}`;
                            surfaceQualityEl.style.backgroundColor = color;
                            surfaceQualityEl.style.color = 'white';

                            // Actualizar el retículo
                            reticle.visible = true;

                            // Aplicar la matriz de transformación completa al retículo
                            reticle.matrix.fromArray(pose.transform.matrix);
                            reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);

                            // Ajustar el tamaño basado en la distancia
                            const scaleFactor = Math.max(0.5, Math.min(1.5, distance));
                            reticle.scale.set(scaleFactor, scaleFactor, scaleFactor);

                            // Cambiar color según calidad
                            reticle.children.forEach(child => {
                                if (child.material && child.material.color) {
                                    // El plano semitransparente (índice 4) cambia de color según calidad
                                    if (child === reticle.children[4]) {
                                        child.material.color.set(color);
                                    }
                                }
                            });
                        } else if (hitTestResults.length === 0) {
                            reticle.visible = false;
                            document.getElementById('distance-indicator').style.display = 'none';
                            document.getElementById('surface-quality').style.display = 'none';
                        }
                    }
                }
            }

            // Rotación del cubo solo si no está siendo manipulado
            if (cube.visible && !isMovingObject && !isScalingObject) {
                cube.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }

        // Loop de animación para entorno 3D (no AR)
        function animate() {
            requestAnimationFrame(animate);

            // Rotación del cubo
            if (cube.visible) {
                cube.rotation.y += 0.01;
                cube.rotation.x += 0.005;
            }

            renderer.render(scene, camera);
        }

        // Salir de AR
        function exitAR() {
            if (arSession) {
                // Eliminar eventos de manipulación
                const canvas = renderer.domElement;
                canvas.removeEventListener('touchstart', onTouchStart);
                canvas.removeEventListener('touchmove', onTouchMove);
                canvas.removeEventListener('touchend', onTouchEnd);

                arSession.end();
                arSession = null;
                isARActive = false;
                isObjectPlaced = false;
            }

            // Volver a la página de detalle del producto
            window.location.href = '@Url.Action("Detalle", "Productos", new { id = ViewBag.ProductoId })';
        }

        // Manejar redimensionamiento de ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Event listener para el botón de inicio
        document.getElementById('start-ar-button').addEventListener('click', startAR);

        // Inicialización
        detectDevice();
        initThreeJS();

        // Si es escritorio, iniciar animación automáticamente
        if (!isMobile) {
            animate();
        }
    </script>
</body>
</html>