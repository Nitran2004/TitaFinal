@{
    Layout = null;
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Optimizado - @ViewBag.ProductoNombre</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 50%, #0c0c0c 100%);
            color: #ffffff;
            overflow: hidden;
            font-weight: 400;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

            canvas:active {
                cursor: grabbing;
            }

        /* UI Principal con Pestañas */
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        /* Sistema de Pestañas */
        .tabs-container {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab-button {
            flex: 1;
            padding: 12px 16px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
        }

            .tab-button:hover {
                background: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.9);
            }

            .tab-button.active {
                background: rgba(76, 175, 80, 0.15);
                color: #4CAF50;
                border-bottom-color: #4CAF50;
            }

        .tab-content {
            padding: 24px;
            text-align: center;
            display: none;
        }

            .tab-content.active {
                display: block;
            }

            /* Contenido de Pestañas */
            .tab-content h3 {
                font-weight: 600;
                font-size: 20px;
                margin-bottom: 8px;
                background: linear-gradient(135deg, #fff 0%, #a0a0a0 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }

        #precio {
            font-size: 18px;
            font-weight: 500;
            color: #4CAF50;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 16px;
            line-height: 1.5;
        }

        /* Tablas de Información */
        .info-table {
            width: 100%;
            margin-top: 16px;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
        }

            .info-table tr {
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

                .info-table tr:last-child {
                    border-bottom: none;
                }

            .info-table td {
                padding: 12px 16px;
                text-align: left;
                font-size: 14px;
            }

                .info-table td:first-child {
                    font-weight: 600;
                    color: rgba(255, 255, 255, 0.9);
                    width: 40%;
                }

                .info-table td:last-child {
                    color: rgba(255, 255, 255, 0.7);
                }

        /* Lista de Alérgenos */
        .allergen-list {
            list-style: none;
            margin-top: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
        }

            .allergen-list li {
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 14px;
                color: rgba(255, 255, 255, 0.8);
                display: flex;
                align-items: center;
            }

                .allergen-list li:last-child {
                    border-bottom: none;
                }

                .allergen-list li:before {
                    content: "⚠️";
                    margin-right: 12px;
                    font-size: 16px;
                }

        /* Mensaje cuando no hay datos */
        .no-data {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            font-size: 14px;
            margin-top: 16px;
        }

        /* Botones */
        .btn {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(76, 175, 80, 0.1) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #ffffff;
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 14px 28px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.2);
            font-family: 'Inter', sans-serif;
            text-decoration: none;
            display: inline-block;
        }

            .btn:hover {
                background: linear-gradient(135deg, rgba(76, 175, 80, 0.3) 0%, rgba(76, 175, 80, 0.2) 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
                border-color: rgba(76, 175, 80, 0.5);
            }

            .btn:disabled {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.1);
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
                color: rgba(255, 255, 255, 0.4);
            }

        .btn-primary {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(59, 130, 246, 0.1) 100%);
            border-color: rgba(59, 130, 246, 0.3);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2);
        }

            .btn-primary:hover {
                background: linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(59, 130, 246, 0.2) 100%);
                border-color: rgba(59, 130, 246, 0.5);
                box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
            }

        .btn-danger {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(239, 68, 68, 0.1) 100%);
            border-color: rgba(239, 68, 68, 0.3);
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.2);
        }

            .btn-danger:hover {
                background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(239, 68, 68, 0.2) 100%);
                border-color: rgba(239, 68, 68, 0.5);
                box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3);
            }

        .btn-small {
            font-size: 12px;
            padding: 8px 16px;
            margin: 4px;
        }

        .btn-collapse {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
            border-radius: 8px;
        }

            .btn-collapse:hover {
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%);
                border-color: rgba(255, 255, 255, 0.5);
                box-shadow: 0 6px 20px rgba(255, 255, 255, 0.2);
            }

        #status {
            margin: 16px 0;
            font-size: 14px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
        }

        .hidden {
            display: none !important;
        }

        /* Panel de Debug - OCULTO PARA USUARIO FINAL */
        #debugInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(34, 197, 94, 0.3);
            padding: 20px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 400;
            z-index: 150;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            font-family: 'Monaco', 'Courier New', monospace;
            color: #10b981;
            display: none !important;
        }

        /* Controles de Vista Previa */
        #previewControls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

            .control-row:last-child {
                margin-bottom: 0;
            }

        .instructions {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        /* Instrucciones AR */
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            font-size: 14px;
            font-weight: 400;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .ar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .ar-header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .ar-title {
            font-weight: 600;
            font-size: 16px;
            background: linear-gradient(135deg, #fff 0%, #a0a0a0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .ar-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

            .ar-content.collapsed {
                height: 0;
                padding: 0;
                opacity: 0;
            }

        #instructions p {
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 300;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 16px;
        }

        @@keyframes spin {
            to

        {
            transform: rotate(360deg);
        }

        }

        /* Información de Escala */
        #scaleInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 24px 32px;
            border-radius: 20px;
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            color: #4CAF50;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(76, 175, 80, 0.2);
        }

        #scaleValue {
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        /* Toggle para Debug - OCULTO */
        #debugToggle {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(16, 185, 129, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            z-index: 160;
            transition: all 0.3s ease;
            display: none !important;
        }

        /* Responsividad */
        @@media (max-width: 768px) {
            #ui

        {
            left: 12px;
            right: 12px;
            top: 12px;
        }

        .tab-button {
            font-size: 12px;
            padding: 10px 12px;
        }

        .tab-content {
            padding: 16px;
        }

            .tab-content h3 {
                font-size: 18px;
            }

        #previewControls, #instructions {
            left: 12px;
            right: 12px;
            bottom: 12px;
            padding: 16px;
        }

        .control-row {
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            font-size: 14px;
            padding: 12px 20px;
        }

        #scaleInfo {
            font-size: 18px;
            padding: 20px 24px;
        }

        .ar-header {
            flex-direction: column;
            gap: 8px;
        }

        .ar-header-buttons {
            gap: 6px;
        }

        .info-table td {
            padding: 8px 12px;
            font-size: 12px;
        }

        .allergen-list li {
            padding: 10px 12px;
            font-size: 12px;
        }

        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Loading -->
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div>Cargando modelo 3D...</div>
    </div>

    <!-- UI Principal con Pestañas -->
    <div id="ui">
        <!-- Pestañas -->
        <div class="tabs-container">
            <button class="tab-button active" onclick="showTab('general')">
                <span>🏷️ General</span>
            </button>
            <button class="tab-button" onclick="showTab('nutrition')">
                <span>📊 Nutrición</span>
            </button>
            <button class="tab-button" onclick="showTab('allergens')">
                <span>⚠️ Alérgenos</span>
            </button>
        </div>

        <!-- Contenido General -->
        <div class="tab-content active" id="tab-general">
            <h3>@ViewBag.ProductoNombre</h3>
            @if (ViewBag.ProductoPrecio != null)
            {
                <div id="precio">$@ViewBag.ProductoPrecio</div>
            }
            @if (!string.IsNullOrEmpty(ViewBag.ProductoDescripcion?.ToString()))
            {
                <div class="description">@ViewBag.ProductoDescripcion</div>
            }
            <div id="status">Preparando modelo...</div>
        </div>

        <!-- Contenido Nutricional -->
        <div class="tab-content" id="tab-nutrition">
            <h3>Información Nutricional</h3>
            @if (!string.IsNullOrEmpty(ViewBag.InfoNutricional?.ToString()))
            {
                <table class="info-table">
                    @foreach (var linea in ViewBag.InfoNutricional.ToString().Split('|'))
                    {
                        var partes = linea.Split(':');
                        if (partes.Length == 2)
                        {
                            <tr>
                                <td>@partes[0]</td>
                                <td>@partes[1]</td>
                            </tr>
                        }
                    }
                </table>
            }
            else
            {
                <table class="info-table">
                    <tr><td>Peso</td><td>210g</td></tr>
                    <tr><td>Calorías</td><td>517Kcal - 26%</td></tr>
                    <tr><td>Grasas</td><td>26g - 33%</td></tr>
                    <tr><td>Carbohidratos</td><td>42g - 14%</td></tr>
                    <tr><td>Proteínas</td><td>28g - 57%</td></tr>
                    <tr><td>Sodio</td><td>1020mg - 42%</td></tr>
                </table>
            }
        </div>

        <!-- Contenido Alérgenos -->
        <div class="tab-content" id="tab-allergens">
            <h3>Información de Alérgenos</h3>
            @if (!string.IsNullOrEmpty(ViewBag.Alergenos?.ToString()))
            {
                <ul class="allergen-list">
                    @foreach (var alergeno in ViewBag.Alergenos.ToString().Split('|'))
                    {
                        <li>@alergeno</li>
                    }
                </ul>
            }
            else
            {
                <ul class="allergen-list">
                    <li>Contiene lácteos</li>
                    <li>Puede contener gluten</li>
                    <li>Puede contener trazas de frutos secos</li>
                </ul>
            }
        </div>
    </div>

    <!-- Toggle Debug - OCULTO PARA USUARIO FINAL PERO FUNCIONAL -->
    <button id="debugToggle" onclick="toggleDebugInfo()">Debug</button>

    <!-- Panel de Debug - OCULTO PARA USUARIO FINAL PERO FUNCIONAL -->
    <div id="debugInfo">
        <h4>Debug AR</h4>
        <div class="debug-section">
            <h5>Modelo</h5>
            <div class="debug-item">
                <span class="debug-label">Estado:</span>
                <span class="debug-value" id="debug-loaded">❌</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Tamaño:</span>
                <span class="debug-value" id="debug-size-current">Calculando...</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Escala:</span>
                <span class="debug-value" id="debug-scale-current">1.0x</span>
            </div>
        </div>
        <div class="debug-section">
            <h5>Posición AR</h5>
            <div class="debug-item">
                <span class="debug-label">Modelo:</span>
                <span class="debug-value" id="debug-pos-model">0, 0, 0</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Cursor:</span>
                <span class="debug-value" id="debug-pos-cursor">0, 0, 0</span>
            </div>
        </div>
        <div class="debug-section">
            <h5>Estado AR</h5>
            <div class="debug-item">
                <span class="debug-label">Modo:</span>
                <span class="debug-value" id="debug-mode">Vista Previa</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Cursor:</span>
                <span class="debug-value" id="debug-cursor-status">❌</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Colocado:</span>
                <span class="debug-value" id="debug-placed">❌ No colocado</span>
            </div>
        </div>
    </div>

    <!-- Controles de Vista Previa Simplificados -->
    <div id="previewControls">
        <div class="instructions">
            <br><strong>En AR:</strong> Usa pellizco de dedos para redimensionar después de colocar.
        </div>
        <div class="control-row">
            <button class="btn btn-primary" id="startARButton" onclick="startAR()" disabled>🚀 Iniciar AR</button>
        </div>
    </div>

    <!-- Instrucciones AR con Controles Integrados -->
    <div id="instructions" class="hidden">
        <div class="ar-header">
            <div class="ar-header-buttons">
                <button class="btn btn-collapse" id="relocateBtn" onclick="relocateModel()" title="Reubicar modelo">
                    <span>🔄</span>
                </button>
                <button class="btn btn-collapse" id="collapseBtn" onclick="toggleARCollapse()">
                    <span id="collapseIcon">🔽</span>
                </button>
            </div>
        </div>
        <div class="ar-content" id="arContent">
            <p>Busca el <strong>cursor verde</strong> moviéndote lentamente</p>
            <p><strong>Toca</strong> para colocar la pizza</p>
            <p><strong>Pellizca con dos dedos</strong> para redimensionar</p>
            <p><strong>Botón 🔄</strong> para reubicar en otra posición</p>
            <div style="margin-top: 20px;">
                <div class="control-row">
                    <button class="btn btn-small" onclick="autoFitModel()">Auto-Ajustar</button>
                </div>
                <div class="control-row">
                    <button class="btn btn-danger" onclick="stopAR()">Salir de AR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Información de Escala durante Pellizco -->
    <div id="scaleInfo">
        Escala: <span id="scaleValue">1.0x</span>
    </div>

    <script>
        // Variables globales
        const PRODUCTO_ID = @ViewBag.ProductoId;
        const PRODUCTO_NOMBRE = '@ViewBag.ProductoNombre';
        const MODELO_ARCHIVO = '@ViewBag.ModeloArchivo';
        const MODELO_PATH = '@Html.Raw(ViewBag.ModeloPath)';

        // Variable para el estado de colapso
        let isARCollapsed = false;

        // Sistema de Pestañas
        function showTab(tabName) {
            // Ocultar todas las pestañas
            const allTabs = document.querySelectorAll('.tab-content');
            const allButtons = document.querySelectorAll('.tab-button');

            allTabs.forEach(tab => tab.classList.remove('active'));
            allButtons.forEach(btn => btn.classList.remove('active'));

            // Mostrar la pestaña seleccionada
            document.getElementById('tab-' + tabName).classList.add('active');
            event.target.closest('.tab-button').classList.add('active');

            console.log('Pestaña cambiada a:', tabName);
        }

        // Clase AR optimizada (mantengo la lógica original)
        class OptimizedWebAR {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.model = null;
                this.isARMode = false;

                // Variables AR
                this.xrSession = null;
                this.xrRefSpace = null;
                this.modelMatrix = new THREE.Matrix4();
                this.modelAdded = false;
                this.hitTestSource = null;
                this.cursor = null;
                this.cursorVisible = false;

                // Objeto de prueba
                this.testCube = null;
                this.useTestMode = false;

                // Debug info
                this.originalBoundingBox = null;
                this.originalCenter = new THREE.Vector3();
                this.originalScale = 1.0;
                this.targetScale = 1.0;
                this.modelLoaded = false;
                this.debugMode = true;
                this.materialStats = { total: 0, converted: 0 };

                this.init();
            }

            async init() {
                console.log('🚀 Iniciando AR Optimizado...');
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.setupLights();
                this.setupControls();
                this.createCursor();
                this.createTestCube();
                await this.loadModel();
                this.setupEventListeners();
                this.animate();
                this.updateDebugInfo();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                const loader = new THREE.CubeTextureLoader();
                const colors = ['#0c0c0c', '#0c0c0c', '#1a1a1a', '#1a1a1a', '#0c0c0c', '#0c0c0c'];
                const texture = loader.load(
                    colors.map(c => `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"><rect width="1" height="1" fill="${c}"/></svg>`)
                );
                this.scene.background = texture;
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
                this.camera.position.set(0, 2, 5);
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.xr.enabled = true;
                this.renderer.shadowMap.enabled = false;
                this.renderer.toneMapping = THREE.NoToneMapping;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                document.getElementById('container').appendChild(this.renderer.domElement);
            }

            setupLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
                directionalLight.position.set(5, 10, 5);
                this.scene.add(directionalLight);

                console.log('💡 Luces optimizadas para AR');
            }

            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 0.5;
                this.controls.maxDistance = 50;
            }

            createTestCube() {
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: false,
                    opacity: 1.0,
                    side: THREE.DoubleSide
                });

                this.testCube = new THREE.Mesh(geometry, material);
                this.testCube.visible = false;
                this.scene.add(this.testCube);
                console.log('🧪 Cubo de prueba creado');
            }

            createCursor() {
                const group = new THREE.Group();

                const size = 0.5;
                const divisions = 12;
                const gridHelper = new THREE.GridHelper(size, divisions, 0x00ff00, 0x00ff00);
                gridHelper.material.opacity = 0.9;
                gridHelper.material.transparent = true;
                group.add(gridHelper);

                group.visible = false;
                this.cursor = group;
                this.scene.add(this.cursor);
            }

            async loadModel() {
                const statusEl = document.getElementById('status');
                const loadingEl = document.getElementById('loading');

                try {
                    statusEl.textContent = `Cargando modelo para debug...`;

                    const modeloArchivo = MODELO_ARCHIVO || 'pizza2.glb';
                    console.log(`Cargando: ${modeloArchivo}`);

                    const loader = new THREE.GLTFLoader();
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(
                            `/models3d/${modeloArchivo}`,
                            resolve,
                            (progress) => {
                                const percent = Math.round((progress.loaded / progress.total) * 100);
                                statusEl.textContent = `Cargando... ${percent}%`;
                            },
                            reject
                        );
                    });

                    this.model = new THREE.Group();
                    const originalModel = gltf.scene;

                    console.log('GLTF cargado:', gltf);

                    this.analyzeModelStructure(originalModel);
                    this.calculateOriginalBoundingBox(originalModel);
                    this.analyzeAndConvertMaterials(originalModel);

                    const box = new THREE.Box3().setFromObject(originalModel);
                    const center = box.getCenter(new THREE.Vector3());

                    originalModel.position.sub(center);
                    this.model.add(originalModel);

                    console.log(`📐 Modelo centrado en wrapper:`);
                    console.log(`  - Centro original: ${center.x.toFixed(3)}, ${center.y.toFixed(3)}, ${center.z.toFixed(3)}`);
                    console.log(`  - Posición en wrapper: ${originalModel.position.x.toFixed(3)}, ${originalModel.position.y.toFixed(3)}, ${originalModel.position.z.toFixed(3)}`);

                    this.model.position.set(0, 0, 0);
                    this.autoFitModel();
                    this.model.visible = true;
                    this.scene.add(this.model);
                    this.modelLoaded = true;

                    this.fitCameraToModel();
                    loadingEl.style.display = 'none';

                    statusEl.textContent = ``;
                    console.log('Modelo procesado con wrapper - Debería posicionarse como el cubo');

                    await this.checkARSupport();
                    this.updateDebugInfo();

                } catch (error) {
                    console.error('Error cargando modelo:', error);
                    statusEl.textContent = `Error: ${error.message}`;
                    loadingEl.style.display = 'none';
                    this.createFallbackCube();
                }
            }

            // Métodos para pellizco de dedos en AR
            onTouchStart(event) {
                if (!this.isARMode || !this.modelAdded) return;

                this.lastTouches = Array.from(event.touches);

                if (event.touches.length === 2) {
                    event.preventDefault();
                    this.isScaling = true;
                    this.initialDistance = this.getDistance(event.touches[0], event.touches[1]);
                    this.initialScale = this.currentScale;

                    console.log('Iniciando pellizco de dedos');
                    console.log(`Distancia inicial: ${this.initialDistance.toFixed(0)}px`);
                    console.log(`Escala inicial: ${this.initialScale.toFixed(2)}x`);

                    this.showScaleInfo();
                }
            }

            onTouchMove(event) {
                if (!this.isARMode || !this.modelAdded || !this.isScaling) return;

                if (event.touches.length === 2) {
                    event.preventDefault();

                    const currentDistance = this.getDistance(event.touches[0], event.touches[1]);
                    const scaleChange = currentDistance / this.initialDistance;

                    this.currentScale = Math.max(0.2, Math.min(5.0, this.initialScale * scaleChange));

                    this.updateModelScale();
                    this.updateScaleDisplay();
                    this.updateDebugInfo();
                }
            }

            onTouchEnd(event) {
                if (!this.isARMode || !this.modelAdded) return;

                if (event.touches.length < 2) {
                    this.isScaling = false;
                    console.log(`Pellizco terminado - Escala final: ${this.currentScale.toFixed(2)}x`);

                    this.hideScaleInfo();
                    this.updateDebugInfo();
                }
            }

            getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            updateModelScale() {
                if (!this.model || !this.modelAdded) return;

                const objectToScale = this.useTestMode ? this.testCube : this.model;
                const finalScale = this.targetScale * this.currentScale;
                objectToScale.scale.setScalar(finalScale);

                console.log(`📏 Escala aplicada: ${finalScale.toFixed(3)}x (base: ${this.targetScale.toFixed(2)}x × pellizco: ${this.currentScale.toFixed(2)}x)`);
            }

            updateScaleDisplay() {
                const scaleValueEl = document.getElementById('scaleValue');
                if (scaleValueEl) {
                    scaleValueEl.textContent = this.currentScale.toFixed(1) + 'x';
                }
            }

            showScaleInfo() {
                const scaleInfoEl = document.getElementById('scaleInfo');
                if (scaleInfoEl) {
                    scaleInfoEl.style.opacity = '1';
                    scaleInfoEl.style.pointerEvents = 'none';

                    if (this.scaleTimeout) {
                        clearTimeout(this.scaleTimeout);
                    }
                }
            }

            hideScaleInfo() {
                const scaleInfoEl = document.getElementById('scaleInfo');
                if (scaleInfoEl) {
                    this.scaleTimeout = setTimeout(() => {
                        scaleInfoEl.style.opacity = '0';
                    }, 2000);
                }
            }

            analyzeModelStructure(model = this.model) {
                if (!model) return;

                let nodeCount = 0;
                let meshCount = 0;
                let materialCount = 0;

                model.traverse((node) => {
                    nodeCount++;
                    if (node.isMesh) {
                        meshCount++;
                        if (node.material) {
                            materialCount++;
                        }
                    }
                });

                console.log(`📊 ESTRUCTURA DEL MODELO:`);
                console.log(`  - Nodos totales: ${nodeCount}`);
                console.log(`  - Meshes: ${meshCount}`);
                console.log(`  - Materiales: ${materialCount}`);
                console.log(`  - Tipo: ${model.type}`);
                console.log(`  - Hijos: ${model.children.length}`);

                this.materialStats.total = materialCount;
            }

            calculateOriginalBoundingBox(model = this.model) {
                if (!model) return;

                this.originalBoundingBox = new THREE.Box3().setFromObject(model);
                const size = this.originalBoundingBox.getSize(new THREE.Vector3());
                this.originalCenter = this.originalBoundingBox.getCenter(new THREE.Vector3());

                console.log(`📐 DIMENSIONES ORIGINALES:`);
                console.log(`  - Tamaño: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}`);
                console.log(`  - Centro: ${this.originalCenter.x.toFixed(3)}, ${this.originalCenter.y.toFixed(3)}, ${this.originalCenter.z.toFixed(3)}`);
                console.log(`  - Min: ${this.originalBoundingBox.min.x.toFixed(3)}, ${this.originalBoundingBox.min.y.toFixed(3)}, ${this.originalBoundingBox.min.z.toFixed(3)}`);
                console.log(`  - Max: ${this.originalBoundingBox.max.x.toFixed(3)}, ${this.originalBoundingBox.max.y.toFixed(3)}, ${this.originalBoundingBox.max.z.toFixed(3)}`);
            }

            analyzeAndConvertMaterials(model = this.model) {
                if (!model) return;

                let converted = 0;
                model.traverse((node) => {
                    if (node.isMesh && node.material) {
                        const originalMaterial = node.material;

                        const newMaterial = new THREE.MeshBasicMaterial({
                            transparent: false,
                            opacity: 1.0,
                            side: THREE.DoubleSide,
                            wireframe: false
                        });

                        if (originalMaterial.color) {
                            newMaterial.color = originalMaterial.color.clone();
                        } else {
                            newMaterial.color = new THREE.Color(0xffffff);
                        }

                        if (originalMaterial.map) {
                            newMaterial.map = originalMaterial.map;
                            newMaterial.map.encoding = THREE.sRGBEncoding;
                        }

                        node.material = newMaterial;
                        node.material.needsUpdate = true;
                        converted++;
                    }
                });

                this.materialStats.converted = converted;
                console.log(`🎨 ${converted} materiales optimizados preservando apariencia`);
            }

            autoFitModel() {
                if (!this.model || !this.originalBoundingBox) return;

                const size = this.originalBoundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                let targetSize;
                if (this.isARMode) {
                    targetSize = 0.3;
                } else {
                    targetSize = 2.0;
                }

                this.targetScale = maxDim > 0 ? targetSize / maxDim : 1;
                this.model.scale.setScalar(this.targetScale);

                const finalSize = maxDim * this.targetScale;
                console.log(`ESCALA APLICADA: ${this.targetScale.toFixed(3)}x (${targetSize}m target, final: ${finalSize.toFixed(2)}m)`);

                this.updateDebugInfo();
            }

            fitCameraToModel() {
                if (!this.model || !this.camera || this.isARMode) return;

                const box = new THREE.Box3().setFromObject(this.model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                const fov = this.camera.fov * (Math.PI / 180);
                const cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2))) * 2;

                this.camera.position.set(center.x, center.y + size.y / 2, center.z + cameraZ);

                if (this.controls) {
                    this.controls.target.copy(center);
                    this.controls.update();
                }

                console.log(`📷 Cámara ajustada: distancia ${cameraZ.toFixed(2)}m`);
            }

            createFallbackCube() {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff6b35 });
                this.model = new THREE.Mesh(geometry, material);
                this.model.visible = true;
                this.scene.add(this.model);
                this.modelLoaded = true;

                this.originalBoundingBox = new THREE.Box3().setFromObject(this.model);
                this.originalCenter = this.originalBoundingBox.getCenter(new THREE.Vector3());
                this.autoFitModel();
                this.fitCameraToModel();
                this.updateDebugInfo();

                document.getElementById('loading').style.display = 'none';
                console.log('Cubo de respaldo creado');
            }

            async checkARSupport() {
                const buttonEl = document.getElementById('startARButton');

                if (navigator.xr) {
                    try {
                        const supported = await navigator.xr.isSessionSupported('immersive-ar');
                        if (supported) {
                            buttonEl.disabled = false;
                            console.log('AR soportado');
                        } else {
                            console.log('AR no soportado en este dispositivo');
                        }
                    } catch (error) {
                        console.error('Error checking AR:', error);
                    }
                } else {
                    console.log('WebXR no disponible');
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.updateDebugInfo();
                });

                document.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });

                console.log('👆 Event listeners configurados para pellizco de dedos');
            }

            updateDebugInfo() {
                if (!this.debugMode) return;

                document.getElementById('debug-loaded').textContent = this.modelLoaded ? 'Cargado' : 'No cargado';

                if (this.originalBoundingBox) {
                    const originalSize = this.originalBoundingBox.getSize(new THREE.Vector3());
                    const currentSize = originalSize.clone().multiplyScalar(this.targetScale);
                    document.getElementById('debug-size-current').textContent =
                        `${currentSize.x.toFixed(2)}×${currentSize.y.toFixed(2)}×${currentSize.z.toFixed(2)}m`;
                }

                const displayScale = this.isARMode && this.modelAdded ?
                    this.targetScale * this.currentScale : this.targetScale;
                document.getElementById('debug-scale-current').textContent = `${displayScale.toFixed(2)}x`;

                if (this.isScaling) {
                    console.log(`Pellizco activo: ${this.currentScale.toFixed(2)}x`);
                }

                if (this.model) {
                    const pos = this.model.position;
                    document.getElementById('debug-pos-model').textContent =
                        `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
                }

                if (this.cursor) {
                    const cPos = this.cursor.position;
                    document.getElementById('debug-pos-cursor').textContent =
                        `${cPos.x.toFixed(2)}, ${cPos.y.toFixed(2)}, ${cPos.z.toFixed(2)}`;
                }

                document.getElementById('debug-mode').textContent = this.isARMode ? 'AR' : 'Preview';
                document.getElementById('debug-cursor-status').textContent = this.cursorVisible ? 'Visible' : 'Oculto';
                document.getElementById('debug-placed').textContent = this.modelAdded ? 'Colocado' : 'No colocado';
            }

            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                const debugEl = document.getElementById('debugInfo');
                debugEl.style.display = this.debugMode ? 'block' : 'none';
            }

            toggleTestMode() {
                this.useTestMode = !this.useTestMode;
                const btn = document.getElementById('testModeBtn');
                const arText = document.getElementById('ar-mode-text');

                btn.textContent = this.useTestMode ? 'Cubo: ON' : 'Cubo: OFF';
                btn.className = this.useTestMode ? 'btn btn-primary btn-small' : 'btn btn-small';

                if (arText) {
                    arText.textContent = this.useTestMode ?
                        'Modo: CUBO ROJO (funciona)' :
                        'Modo: MODELO REAL (debug)';
                }

                console.log(`Modo de prueba: ${this.useTestMode ? 'ACTIVADO' : 'DESACTIVADO'}`);
            }

            async startAR() {
                if (!this.modelLoaded || this.isARMode) return;

                const statusEl = document.getElementById('status');
                const previewEl = document.getElementById('previewControls');
                const instructionsEl = document.getElementById('instructions');

                try {
                    console.log('Iniciando AR...');

                    this.xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['local'],
                        optionalFeatures: ['hit-test', 'dom-overlay'],
                        domOverlay: { root: document.body }
                    });

                    await this.setupXRSession();

                    this.isARMode = true;
                    this.scene.background = null;
                    this.renderer.setClearColor(0x000000, 0);

                    console.log('Preparando objetos para AR...');

                    if (this.useTestMode) {
                        this.testCube.position.set(0, 0, 0);
                        this.testCube.rotation.set(0, 0, 0);
                        this.testCube.quaternion.set(0, 0, 0, 1);
                        this.testCube.scale.setScalar(1.0);
                        this.testCube.visible = false;
                        this.modelAdded = false;
                        console.log('Cubo de prueba preparado (posición inicial: 0,0,0)');
                    } else {
                        console.log('Preparando modelo pizza...');

                        this.model.position.set(0, 0, 0);
                        this.model.rotation.set(0, 0, 0);
                        this.model.quaternion.set(0, 0, 0, 1);
                        this.model.scale.setScalar(1.0);
                        this.model.visible = false;
                        this.modelAdded = false;

                        this.currentScale = 1.0;
                        this.initialScale = 1.0;
                        this.isScaling = false;

                        this.autoFitModel();

                        console.log(`Modelo preparado:`);
                        console.log(`  - Posición wrapper: ${this.model.position.x}, ${this.model.position.y}, ${this.model.position.z}`);
                        console.log(`  - Escala objetivo: ${this.targetScale.toFixed(3)}x`);
                        console.log(`  - Visible: ${this.model.visible}`);

                        console.log(`  - Hijos en wrapper: ${this.model.children.length}`);
                        if (this.model.children.length > 0) {
                            const child = this.model.children[0];
                            console.log(`  - Primer hijo pos: ${child.position.x.toFixed(3)}, ${child.position.y.toFixed(3)}, ${child.position.z.toFixed(3)}`);
                        }

                        this.forceSimpleMaterials();
                    }

                    if (this.controls) this.controls.enabled = false;

                    previewEl.classList.add('hidden');
                    instructionsEl.classList.remove('hidden');

                    this.updateDebugInfo();

                    console.log('AR iniciado correctamente');

                } catch (error) {
                    console.error('Error iniciando AR:', error);
                    statusEl.textContent = `Error AR: ${error.message}`;
                }
            }

            async setupXRSession() {
                this.xrRefSpace = await this.xrSession.requestReferenceSpace('local');
                this.viewerSpace = await this.xrSession.requestReferenceSpace('viewer');

                this.renderer.xr.setReferenceSpaceType('local');
                this.renderer.xr.setSession(this.xrSession);

                await this.setupHitTesting();

                this.xrSession.addEventListener('select', (event) => {
                    this.onSelect(event);
                });

                this.xrSession.addEventListener('end', () => {
                    this.onSessionEnd();
                });

                this.renderer.setAnimationLoop((time, frame) => {
                    this.render(time, frame);
                });
            }

            async setupHitTesting() {
                try {
                    this.hitTestSource = await this.xrSession.requestHitTestSource({ space: this.viewerSpace });
                    console.log('Hit testing configurado');
                } catch (error) {
                    console.warn('Hit testing no disponible:', error);
                }
            }

            render(time, frame) {
                if (this.isARMode && frame && this.hitTestSource && !this.modelAdded) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(this.xrRefSpace);
                        if (pose) {
                            this.modelMatrix.fromArray(pose.transform.matrix);

                            this.cursor.visible = true;
                            this.cursor.position.set(
                                pose.transform.position.x,
                                pose.transform.position.y,
                                pose.transform.position.z
                            );

                            if (!this.cursorVisible) {
                                console.log('Superficie detectada');
                            }
                            this.cursorVisible = true;
                        }
                    } else {
                        this.cursor.visible = false;
                        this.cursorVisible = false;
                    }
                } else if (this.modelAdded && this.cursor) {
                    this.cursor.visible = false;
                    this.cursorVisible = false;
                }

                this.renderer.render(this.scene, this.camera);

                if (this.debugMode) {
                    requestAnimationFrame(() => this.updateDebugInfo());
                }
            }

            onSelect(event) {
                if (!this.modelAdded && this.modelMatrix && this.cursorVisible) {
                    console.log('Colocando objeto en AR...');

                    const objectToPlace = this.useTestMode ? this.testCube : this.model;
                    const objectName = this.useTestMode ? 'CUBO ROJO' : 'MODELO PIZZA';

                    console.log(`Matriz del cursor:`, this.modelMatrix);

                    const position = new THREE.Vector3();
                    const quaternion = new THREE.Quaternion();
                    const scale = new THREE.Vector3();
                    this.modelMatrix.decompose(position, quaternion, scale);

                    console.log(`Posición del hit test: ${position.x.toFixed(3)}, ${position.y.toFixed(3)}, ${position.z.toFixed(3)}`);

                    objectToPlace.position.set(0, 0, 0);
                    objectToPlace.rotation.set(0, 0, 0);
                    objectToPlace.quaternion.set(0, 0, 0, 1);

                    objectToPlace.position.copy(position);
                    objectToPlace.quaternion.copy(quaternion);

                    objectToPlace.position.y += 0.1;

                    console.log(`Posición final del objeto: ${objectToPlace.position.x.toFixed(3)}, ${objectToPlace.position.y.toFixed(3)}, ${objectToPlace.position.z.toFixed(3)}`);

                    if (this.useTestMode) {
                        objectToPlace.scale.setScalar(1.0);
                        this.currentScale = 1.0;
                        console.log('CUBO: Escala 1.0x aplicada');
                    } else {
                        objectToPlace.scale.setScalar(this.targetScale);
                        this.currentScale = 1.0;
                        console.log(`MODELO: Escala ${this.targetScale.toFixed(3)}x aplicada`);
                        console.log(`Pellizco habilitado - Usa dos dedos para redimensionar`);

                        objectToPlace.traverse((node, index) => {
                            if (node.isMesh) {
                                console.log(`  🔸 Mesh ${index}: visible=${node.visible}, pos=(${node.position.x.toFixed(2)},${node.position.y.toFixed(2)},${node.position.z.toFixed(2)})`);
                            }
                        });
                    }

                    objectToPlace.visible = true;
                    this.modelAdded = true;
                    this.cursor.visible = false;

                    console.log(`${objectName} colocado con lógica idéntica al cubo`);
                    console.log(`Comparación de posiciones:`);
                    console.log(`  - Cursor: ${position.x.toFixed(3)}, ${position.y.toFixed(3)}, ${position.z.toFixed(3)}`);
                    console.log(`  - Objeto: ${objectToPlace.position.x.toFixed(3)}, ${objectToPlace.position.y.toFixed(3)}, ${objectToPlace.position.z.toFixed(3)}`);
                    console.log(`  - Diferencia Y: +${(objectToPlace.position.y - position.y).toFixed(3)} (elevación)`);

                    this.updateDebugInfo();
                }
            }

            forceSimpleMaterials() {
                if (!this.model) return;

                console.log('Optimizando materiales para AR...');
                let count = 0;

                this.model.traverse((node) => {
                    if (node.isMesh && node.material) {
                        const originalMaterial = node.material;

                        const newMaterial = new THREE.MeshBasicMaterial({
                            transparent: false,
                            opacity: 1.0,
                            side: THREE.DoubleSide,
                            wireframe: false,
                            fog: false
                        });

                        if (originalMaterial.color) {
                            newMaterial.color = originalMaterial.color.clone();
                            newMaterial.color.multiplyScalar(1.1);
                        } else {
                            newMaterial.color = new THREE.Color(0xdddddd);
                        }

                        if (originalMaterial.map) {
                            newMaterial.map = originalMaterial.map;
                        }

                        node.material = newMaterial;
                        node.material.needsUpdate = true;
                        count++;
                    }
                });

                console.log(`${count} materiales optimizados`);
                this.materialStats.converted = count;
                this.updateDebugInfo();
            }

            stopAR() {
                if (!this.isARMode || !this.xrSession) return;
                console.log('Deteniendo AR...');
                this.xrSession.end();
            }

            onSessionEnd() {
                console.log('=== SESIÓN AR TERMINADA ===');

                const statusEl = document.getElementById('status');
                const previewEl = document.getElementById('previewControls');
                const instructionsEl = document.getElementById('instructions');

                this.isARMode = false;

                const loader = new THREE.CubeTextureLoader();
                const colors = ['#0c0c0c', '#0c0c0c', '#1a1a1a', '#1a1a1a', '#0c0c0c', '#0c0c0c'];
                const texture = loader.load(
                    colors.map(c => `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"><rect width="1" height="1" fill="${c}"/></svg>`)
                );
                this.scene.background = texture;
                this.renderer.setClearColor(0x0c0c0c, 1);

                this.xrSession = null;
                this.xrRefSpace = null;
                this.hitTestSource = null;
                this.modelAdded = false;

                if (this.model) {
                    this.model.visible = true;
                    this.autoFitModel();
                    this.model.position.set(0, 0, 0);
                    this.fitCameraToModel();
                }

                if (this.testCube) {
                    this.testCube.visible = false;
                    this.testCube.position.set(0, 0, 0);
                    this.testCube.scale.setScalar(1.0);
                }

                this.currentScale = 1.0;
                this.initialScale = 1.0;
                this.isScaling = false;
                this.hideScaleInfo();

                if (this.controls) this.controls.enabled = true;
                if (this.cursor) this.cursor.visible = false;

                previewEl.classList.remove('hidden');
                instructionsEl.classList.add('hidden');

                isARCollapsed = false;
                const arContent = document.getElementById('arContent');
                const collapseIcon = document.getElementById('collapseIcon');
                if (arContent) arContent.classList.remove('collapsed');
                if (collapseIcon) collapseIcon.textContent = '🔽';

                this.renderer.setAnimationLoop(null);

                statusEl.textContent = `Debug AR terminado`;
                this.updateDebugInfo();
            }

            relocateModel() {
                if (!this.isARMode || !this.modelAdded) {
                    console.log('No se puede reubicar: no estamos en AR o no hay modelo colocado');
                    return;
                }

                console.log('🔄 Reubicando modelo...');

                // Ocultar el modelo actual
                const objectToHide = this.useTestMode ? this.testCube : this.model;
                objectToHide.visible = false;

                // Resetear estado de colocación
                this.modelAdded = false;

                // Resetear escalas y pellizco
                this.currentScale = 1.0;
                this.initialScale = 1.0;
                this.isScaling = false;

                // Ocultar información de escala
                this.hideScaleInfo();

                // Resetear posición y rotación del objeto
                objectToHide.position.set(0, 0, 0);
                objectToHide.rotation.set(0, 0, 0);
                objectToHide.quaternion.set(0, 0, 0, 1);

                // Restaurar escala base
                if (this.useTestMode) {
                    objectToHide.scale.setScalar(1.0);
                } else {
                    objectToHide.scale.setScalar(this.targetScale);
                }

                // El cursor volverá a aparecer automáticamente en el próximo frame
                // cuando el hit testing detecte superficies

                console.log('✅ Modelo listo para reubicación');
                console.log('   - Busca la rejilla verde moviéndote lentamente');
                console.log('   - Toca para colocar en nueva posición');

                this.updateDebugInfo();
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (!this.isARMode) {
                    if (this.controls) this.controls.update();
                    if (this.renderer && this.scene && this.camera) {
                        this.renderer.render(this.scene, this.camera);
                    }
                }
            }
        }

        // Variables globales
        let app;

        // Funciones globales
        function autoFitModel() {
            if (app) app.autoFitModel();
        }

        function toggleDebugInfo() {
            if (app) app.toggleDebugMode();
        }

        function toggleTestMode() {
            if (app) app.toggleTestMode();
        }

        function startAR() {
            if (app) app.startAR();
        }

        function stopAR() {
            if (app) app.stopAR();
        }

        function relocateModel() {
            if (app) app.relocateModel();
        }

        function toggleARCollapse() {
            isARCollapsed = !isARCollapsed;
            const arContent = document.getElementById('arContent');
            const collapseIcon = document.getElementById('collapseIcon');

            if (isARCollapsed) {
                arContent.classList.add('collapsed');
                collapseIcon.textContent = '🔼';
                console.log('Panel AR colapsado');
            } else {
                arContent.classList.remove('collapsed');
                collapseIcon.textContent = '🔽';
                console.log('Panel AR expandido');
            }
        }

        // Inicializar
        document.addEventListener('DOMContentLoaded', () => {
            console.log('=== AR OPTIMIZADO CON PESTAÑAS INICIADO ===');
            console.log(`Producto: ${PRODUCTO_NOMBRE} (ID: ${PRODUCTO_ID})`);
            console.log(`Modelo: ${MODELO_ARCHIVO}`);

            app = new OptimizedWebAR();
        });

        // Manejo de errores
        window.addEventListener('error', (e) => {
            console.error('Error global:', e.error);
            const statusEl = document.getElementById('status');
            if (statusEl) statusEl.textContent = 'Error: ' + e.message;
        });
    </script>
</body>
</html>