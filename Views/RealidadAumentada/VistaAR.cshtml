@{
    ViewData["Title"] = "Vista AR";
    Layout = null;
}
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>@ViewData["Title"] - @ViewBag.ProductoNombre</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: sans-serif;
            width: 100%;
            height: 100%;
            position: fixed;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background: #000;
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .btn {
            position: absolute;
            padding: 12px 20px;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
        }

        #start-btn {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
        }

        #exit-btn {
            top: 20px;
            right: 20px;
            display: none;
            background: rgba(255,255,255,0.8);
            color: #333;
        }

        #ar-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
        }

        #ar-status, #controls, #gesture, #distance, #surface, #loading {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 15px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 10;
        }

        #ar-status {
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
        }

        #controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 13px;
        }

        #gesture {
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #distance {
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
        }

        #surface {
            left: 50%;
            top: 70%;
            transform: translateX(-50%);
        }

        #loading {
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <div id="ar-info">
            <div>Producto: @ViewBag.ProductoNombre - $@ViewBag.ProductoPrecio</div>
            <div id="device-info">Detectando dispositivo...</div>
            <div id="model-info">@(string.IsNullOrEmpty(ViewBag.ModeloPath) ? "Modelo: Por defecto" : "Modelo: Personalizado")</div>
        </div>
        <div id="ar-status">Mueve el dispositivo para detectar superficies</div>
        <div id="loading">Cargando modelo 3D...</div>
        <button id="start-btn" class="btn">Iniciar Realidad Aumentada</button>
        <button id="exit-btn" class="btn">Salir</button>
        <div id="distance">Distancia: -- cm</div>
        <div id="surface"></div>
        <div id="controls">Arrastra para mover • Pellizca para escalar</div>
        <div id="gesture"></div>
    </div>

    <script>
        // Variables principales
        let scene, camera, renderer;
        let object3D; // Referencia al objeto 3D principal (modelo o cubo)
        let modelReady = false; // Indica si el modelo está listo
        let reticle;
        let arSession = null, hitTestSource = null;
        let isARActive = false, isObjectPlaced = false;
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        // Obtener la ruta del modelo del ViewBag
        const modelPath = '@ViewBag.ModeloPath';
        const productName = '@ViewBag.ProductoNombre';

        // Referencias DOM
        const startBtn = document.getElementById('start-btn');
        const exitBtn = document.getElementById('exit-btn');
        const deviceInfo = document.getElementById('device-info');
        const arStatus = document.getElementById('ar-status');
        const controls = document.getElementById('controls');
        const gesture = document.getElementById('gesture');
        const distance = document.getElementById('distance');
        const surface = document.getElementById('surface');
        const loading = document.getElementById('loading');

        // Inicialización
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', onResize);
        startBtn.addEventListener('click', startAR);
        exitBtn.addEventListener('click', exitAR);

        function init() {
            deviceInfo.textContent = isMobile ? 'Dispositivo móvil' : 'Escritorio';

            // Inicializar Three.js
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.getElementById('ar-container').appendChild(renderer.domElement);

            // Luces
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(1, 2, 1);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Crear objeto 3D según el tipo de producto
            createObject3D();

            // Crear retículo para AR
            createReticle();

            // Si es escritorio, iniciar vista 3D en cuanto el modelo esté listo
            if (!isMobile) {
                if (modelReady) {
                    startDesktopView();
                } else {
                    // Si el modelo aún no está listo, esperar a que cargue
                    const checkInterval = setInterval(() => {
                        if (modelReady) {
                            startDesktopView();
                            clearInterval(checkInterval);
                        }
                    }, 100);
                }
            }

            // Verificar soporte WebXR
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar')
                    .then(supported => {
                        if (isMobile && !supported) startMobile3D();
                    });
            } else if (isMobile) {
                startMobile3D();
            }
        }

        function createObject3D() {
            if (modelPath && modelPath !== '') {
                // Mostrar indicador de carga
                loading.style.display = 'block';

                // Cargar modelo GLB correspondiente
                const loader = new THREE.GLTFLoader();
                loader.load(
                    modelPath,
                    function(gltf) {
                        // Éxito al cargar el modelo
                        object3D = gltf.scene;

                        // Ajustar tamaño y posición según el modelo específico
                        switch(productName.toLowerCase()) {
                            case "pepperoni":
                                object3D.scale.set(0.5, 0.5, 0.5);
                                break;
                            case "mi champ":
                                object3D.scale.set(0.4, 0.4, 0.4);
                                break;
                            default:
                                object3D.scale.set(0.5, 0.5, 0.5);
                        }

                        // Asegurarse de que reciba sombras
                        object3D.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        object3D.visible = false;
                        scene.add(object3D);

                        // Marcar como cargado
                        modelReady = true;
                        loading.style.display = 'none';

                        // Si estamos en escritorio, iniciar la vista
                        if (!isMobile && !isARActive) {
                            startDesktopView();
                        }
                    },
                    // Progreso
                    function(xhr) {
                        const percent = Math.floor((xhr.loaded / xhr.total) * 100);
                        loading.textContent = `Cargando modelo 3D: ${percent}%`;
                    },
                    // Error
                    function(error) {
                        console.error('Error al cargar el modelo:', error);
                        loading.style.display = 'none';
                        // Crear cubo por defecto si hay error
                        createDefaultCube();
                    }
                );
            } else {
                // Si no hay modelo específico, crear cubo rojo por defecto
                createDefaultCube();
            }
        }

        function createDefaultCube() {
            // Crear cubo rojo por defecto
            object3D = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.3, 0.3),
                new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    metalness: 0.1,
                    roughness: 0.5
                })
            );
            object3D.castShadow = true;
            object3D.receiveShadow = true;
            object3D.visible = false;
            scene.add(object3D);

            // Marcar como listo
            modelReady = true;
        }

        function createReticle() {
            reticle = new THREE.Group();

            // Anillo principal
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.05, 0.07, 24),
                new THREE.MeshBasicMaterial({
                    color: 0x0099ff, side: THREE.DoubleSide,
                    transparent: true, opacity: 0.8
                })
            );
            reticle.add(ring);

            // Anillo exterior pulsante
            const outerRing = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.09, 24),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff, side: THREE.DoubleSide,
                    transparent: true, opacity: 0.5
                })
            );
            reticle.add(outerRing);

            // Líneas cruzadas
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8
            });

            const hLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-0.05, 0, 0),
                    new THREE.Vector3(0.05, 0, 0)
                ]),
                lineMaterial
            );
            reticle.add(hLine);

            const vLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -0.05, 0),
                    new THREE.Vector3(0, 0.05, 0)
                ]),
                lineMaterial
            );
            reticle.add(vLine);

            // Plano semitransparente
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 0.15),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00, transparent: true,
                    opacity: 0.2, side: THREE.DoubleSide
                })
            );
            reticle.add(plane);

            reticle.rotation.x = -Math.PI/2;
            reticle.visible = false;
            scene.add(reticle);

            // Animación pulsante simplificada
            function pulse() {
                if (reticle.visible) {
                    const scale = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    outerRing.scale.set(scale, scale, 1);
                }
                requestAnimationFrame(pulse);
            }
            pulse();
        }

        function startDesktopView() {
            // Verificar que el modelo esté listo
            if (!modelReady) {
                setTimeout(startDesktopView, 100);
                return;
            }

            // Fondo y suelo simplificados
            scene.background = new THREE.Color(0x87CEEB);
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({color: 0x3a7b3c, roughness: 0.8})
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Posicionar objeto
            object3D.position.set(0, 0.5, -2);
            object3D.visible = true;

            // Configurar interacción
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);

            controls.textContent = 'Clic y arrastrar para mover • Rueda para escalar';
            controls.style.display = 'block';
            startBtn.style.display = 'none';
            exitBtn.style.display = 'block';

            // Iniciar animación
            animate();
        }

        // Variables para interacción con ratón
        let isMouseDown = false;
        let lastMousePos = {x: 0, y: 0};

        function onMouseDown(e) {
            isMouseDown = true;
            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
            showGesture('✋');
        }

        function onMouseMove(e) {
            if (!isMouseDown) return;
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;

            // Mover objeto
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            object3D.position.add(right.multiplyScalar(dx * 0.01));
            object3D.position.add(forward.multiplyScalar(-dy * 0.01));
            object3D.position.y = 0.5;

            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseWheel(e) {
            const factor = e.deltaY < 0 ? 1.1 : 0.9;
            const newScale = object3D.scale.x * factor;
            const scale = Math.max(0.1, Math.min(2.0, newScale));
            object3D.scale.set(scale, scale, scale);
            showGesture('↔️');
        }

        function startMobile3D() {
            // Esperar a que el modelo esté listo
            if (!modelReady) {
                setTimeout(startMobile3D, 100);
                return;
            }

            // Vista simplificada para móviles sin AR
            object3D.position.set(0, 0, -2);
            object3D.visible = true;

            const canvas = renderer.domElement;
            let touchStart = null;

            canvas.addEventListener('touchstart', e => {
                touchStart = e.touches[0];
            });

            canvas.addEventListener('touchmove', e => {
                if (!touchStart) return;
                const touch = e.touches[0];
                const dx = touch.pageX - touchStart.pageX;
                const dy = touch.pageY - touchStart.pageY;
                object3D.rotation.y += dx * 0.01;
                object3D.rotation.x += dy * 0.01;
                touchStart = touch;
            });

            startBtn.style.display = 'none';
            exitBtn.style.display = 'block';
            animate();
        }

        async function startAR() {
            // Verificar que el modelo esté listo
            if (!modelReady) {
                loading.style.display = 'block';
                loading.textContent = 'Esperando a que el modelo termine de cargar...';
                setTimeout(startAR, 500);
                return;
            }

            if (!isMobile) {
                startDesktopView();
                return;
            }

            arStatus.textContent = 'Solicitando acceso a la cámara...';
            arStatus.style.display = 'block';

            if (!('xr' in navigator)) {
                startMobile3D();
                return;
            }

            try {
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    startMobile3D();
                    return;
                }

                startBtn.style.display = 'none';
                exitBtn.style.display = 'block';

                // Configurar sesión AR
                const sessionInit = {
                    requiredFeatures: ['hit-test'],
                    optionalFeatures: ['dom-overlay']
                };

                if (sessionInit.optionalFeatures.includes('dom-overlay')) {
                    sessionInit.domOverlay = {root: document.getElementById('ar-container')};
                }

                arSession = await navigator.xr.requestSession('immersive-ar', sessionInit);

                // Configurar renderer y eventos
                renderer.xr.setReferenceSpaceType('local');
                await renderer.xr.setSession(arSession);
                arSession.addEventListener('select', onARSelect);
                arSession.addEventListener('end', onARSessionEnd);

                arStatus.textContent = 'Mueve el dispositivo para detectar superficies';
                isARActive = true;

                // Iniciar loop de renderizado
                renderer.setAnimationLoop(renderAR);

            } catch (error) {
                console.error('Error al iniciar AR:', error);
                arStatus.textContent = 'Error: No se pudo acceder a la cámara';
                setTimeout(() => {arStatus.style.display = 'none';}, 3000);
                startBtn.style.display = 'block';
                exitBtn.style.display = 'none';
            }
        }

        function onARSessionEnd() {
            isARActive = false;
            exitBtn.style.display = 'block';

            if (object3D.visible) {
                controls.style.display = 'block';
                setupTouchHandlers();
                animate();
            } else {
                arStatus.textContent = 'Sesión AR interrumpida';
                arStatus.style.display = 'block';
            }
        }

        function onARSelect() {
            if (!reticle.visible || object3D.visible) return;

            // Colocar objeto en posición del retículo
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            reticle.matrix.decompose(position, quaternion, scale);
            object3D.position.copy(position);
            object3D.position.y += 0.15;

            // Orientar según superficie
            const normalVector = new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion);
            const upVector = new THREE.Vector3(0, 1, 0);
            const angle = Math.acos(normalVector.dot(upVector)) * (180/Math.PI);

            if (angle > 45 && angle < 135) {
                object3D.quaternion.copy(quaternion);
                const offset = new THREE.Vector3(0, 0, 0.15).applyQuaternion(quaternion);
                object3D.position.add(offset);
            }

            // Mostrar objeto con animación
            object3D.visible = true;
            // Guardamos la escala original
            const originalScale = {
                x: object3D.scale.x,
                y: object3D.scale.y,
                z: object3D.scale.z
            };
            // Escalamos a cero temporalmente
            object3D.scale.set(
                originalScale.x * 0.1,
                originalScale.y * 0.1,
                originalScale.z * 0.1
            );
            // Animamos para volver a la escala original
            animateScale(object3D, originalScale, 300);

            // Actualizar estado
            isObjectPlaced = true;
            arStatus.style.display = 'none';
            distance.style.display = 'none';
            surface.style.display = 'none';
            controls.style.display = 'block';

            // Configurar manipulación
            setupTouchHandlers();
        }

        // Variables para manipulación táctil
        let isMoving = false, isScaling = false;
        let lastTouch = {x:0, y:0};
        let initialDistance = 0, initialScale = 0;

        function setupTouchHandlers() {
            const canvas = renderer.domElement;

            canvas.removeEventListener('touchstart', onTouchStart);
            canvas.removeEventListener('touchmove', onTouchMove);
            canvas.removeEventListener('touchend', onTouchEnd);

            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);

            // Mostrar gestos
            showGesture('👆');
            setTimeout(() => showGesture('👋'), 1500);
            setTimeout(() => showGesture('👌'), 3000);
        }

        function onTouchStart(e) {
            e.preventDefault();

            if (e.touches.length === 2) {
                isScaling = true;
                isMoving = false;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialScale = object3D.scale.x;

                showGesture('↔️');

            } else if (e.touches.length === 1) {
                isMoving = true;
                isScaling = false;

                const touch = e.touches[0];
                lastTouch.x = touch.clientX;
                lastTouch.y = touch.clientY;

                showGesture('✋');
            }
        }

        function onTouchMove(e) {
            e.preventDefault();

            if (isScaling && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                const factor = currentDistance / initialDistance;
                const newScale = initialScale * factor;
                const scale = Math.max(0.2, Math.min(2.0, newScale));

                object3D.scale.set(scale, scale, scale);

            } else if (isMoving && e.touches.length === 1) {
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouch.x;
                const dy = touch.clientY - lastTouch.y;

                // Mover en el espacio 3D
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

                const distance = camera.position.distanceTo(object3D.position);
                const sensitivity = distance * 0.003;

                object3D.position.add(right.multiplyScalar(dx * sensitivity));
                object3D.position.add(up.multiplyScalar(-dy * sensitivity));

                lastTouch.x = touch.clientX;
                lastTouch.y = touch.clientY;
            }
        }

        function onTouchEnd() {
            isMoving = isScaling = false;
        }

        function showGesture(emoji) {
            gesture.textContent = emoji;
            gesture.style.opacity = '0.8';
            setTimeout(() => {gesture.style.opacity = '0';}, 1000);
        }

        function animateScale(object, target, duration) {
            const start = {
                x: object.scale.x,
                y: object.scale.y,
                z: object.scale.z
            };
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                object.scale.x = start.x + (target.x - start.x) * progress;
                object.scale.y = start.y + (target.y - start.y) * progress;
                object.scale.z = start.z + (target.z - start.z) * progress;

                if (progress < 1) requestAnimationFrame(update);
            }

            update();
        }

        function renderAR(timestamp, frame) {
            if (!frame || !isARActive) return;

            const session = renderer.xr.getSession();
            const referenceSpace = renderer.xr.getReferenceSpace();

            // Solicitar hit test source si es necesario
            if (!hitTestSource) {
                session.requestReferenceSpace('viewer').then(viewerSpace => {
                    session.requestHitTestSource({space: viewerSpace})
                        .then(source => {
                            hitTestSource = source;
                        });
                });

                session.addEventListener('end', () => {
                    hitTestSource = null;
                });
            }

            // Procesar hit test
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);

                if (hitTestResults.length > 0 && !object3D.visible) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(referenceSpace);

                    if (pose) {
                        // Actualizar indicadores
                        const position = pose.transform.position;
                        const distanceVal = Math.sqrt(
                            position.x * position.x +
                            position.y * position.y +
                            position.z * position.z
                        );

                        distance.style.display = 'block';
                        distance.textContent = `Distancia: ${(distanceVal * 100).toFixed(0)} cm`;

                        surface.style.display = 'block';

                        // Evaluar calidad de superficie
                        const normalVector = new THREE.Vector3(0, 0, 1);
                        normalVector.applyQuaternion(new THREE.Quaternion(
                            pose.transform.orientation.x,
                            pose.transform.orientation.y,
                            pose.transform.orientation.z,
                            pose.transform.orientation.w
                        ));

                        const upVector = new THREE.Vector3(0, 1, 0);
                        const angle = Math.acos(normalVector.dot(upVector)) * (180/Math.PI);

                        let quality = 'buena';
                        let color = '#4CAF50';

                        if ((angle < 20 || angle > 160) || (angle > 70 && angle < 110)) {
                            if (distanceVal > 2) {
                                quality = 'lejos';
                                color = '#FFC107';
                            }
                        } else {
                            quality = 'inclinada';
                            color = '#FF9800';

                            if (distanceVal > 1.5) {
                                quality = 'inadecuada';
                                color = '#F44336';
                            }
                        }

                        surface.textContent = `Superficie: ${quality}`;
                        surface.style.backgroundColor = color;

                        // Actualizar retículo
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                        reticle.matrix.decompose(
                            reticle.position,
                            reticle.quaternion,
                            reticle.scale
                        );
                    }
                } else if (hitTestResults.length === 0 && reticle.visible) {
                    reticle.visible = false;
                    distance.style.display = 'none';
                    surface.style.display = 'none';
                }
            }

            // Rotación automática del objeto
            if (object3D.visible && !isMoving && !isScaling) {
                object3D.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (object3D && object3D.visible && !isMoving && !isScaling) {
                object3D.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function exitAR() {
            // Limpiar eventos
            const canvas = renderer.domElement;
            canvas.removeEventListener('touchstart', onTouchStart);
            canvas.removeEventListener('touchmove', onTouchMove);
            canvas.removeEventListener('touchend', onTouchEnd);
            canvas.removeEventListener('mousedown', onMouseDown);
            canvas.removeEventListener('mousemove', onMouseMove);
            canvas.removeEventListener('mouseup', onMouseUp);
            canvas.removeEventListener('wheel', onMouseWheel);

            // Finalizar sesión AR si existe
            if (arSession) {
                arStatus.textContent = 'Cerrando sesión AR...';
                arStatus.style.display = 'block';

                try {
                    arSession.end();
                } catch (e) {
                    console.error('Error al finalizar sesión AR:', e);
                }
            }

            // Detener animación y limpiar
            renderer.setAnimationLoop(null);

            // Volver a la página de detalle
            window.location.href = '@Url.Action("Detalle", "Productos", new { id = ViewBag.ProductoId })';
        }
    </script>
</body>
</html>