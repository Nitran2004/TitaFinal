@{
    ViewData["Title"] = "Visualizador 3D Simple";
    Layout = null;
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador 3D Simple - @ViewBag.ProductoNombre</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: #222;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .header-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .test-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        #canvas-container {
            flex: 1;
            width: 100%;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
            display: none;
            max-width: 80%;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }

        .btn-test {
            background-color: #2196F3;
        }

        .btn-warning {
            background-color: #ff9800;
        }

        .btn-control {
            background-color: #9C27B0;
            margin: 2px;
            padding: 4px 8px;
            font-size: 12px;
        }

        #debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
        }

        #controls-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
        }

        .control-group {
            margin-bottom: 10px;
        }

            .control-group label {
                display: block;
                margin-bottom: 5px;
                color: #fff;
            }

        .control-slider {
            width: 150px;
        }

        #model-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }

        #ai-panel {
            position: absolute;
            top: 200px;
            left: 10px;
            background: rgba(0,100,0,0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            max-width: 300px;
            border: 2px solid #00ff00;
        }

        .ai-decision {
            color: #00ff00;
            font-weight: bold;
        }

        .ai-reasoning {
            color: #ccffcc;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <div class="header-info">
                <h2>@ViewBag.ProductoNombre</h2>
@*                 <small>ID: @ViewBag.ProductoId | Archivo: @ViewBag.ModeloArchivo</small>
 *@            </div>
            <div class="test-buttons">
                <button class="btn" onclick="history.back()">Volver</button>
                <a href="/RealidadAumentada/VistaSimple?id=1" class="btn btn-test">ID 1</a>
                <a href="/RealidadAumentada/VistaSimple?id=2" class="btn btn-test">ID 2</a>
                <a href="/RealidadAumentada/VistaSimple?id=9" class="btn btn-warning">ID 9</a>
                <a href="/RealidadAumentada/VistaSimple?id=10" class="btn btn-warning">ID 10</a>
@*                 <button class="btn btn-control" onclick="resetCamera()">Reset Cámara</button>
                <button class="btn btn-control" onclick="toggleWireframe()">Wireframe</button>
                <button class="btn btn-control" onclick="showBoundingBox()">Bounding Box</button> *@
            </div>
        </header>
        <div id="canvas-container">
            <canvas id="canvas3d"></canvas>
        </div>
        <div id="loading">Cargando modelo 3D...</div>
        <div id="error">
            <h3>Error al cargar el modelo</h3>
            <p id="error-message"></p>
            <button class="btn" onclick="recargarModelo()">Reintentar</button>
        </div>

        <!-- Panel de estadísticas del modelo -->
        <div id="model-stats" style="display: none;">
            <strong>📊 Estadísticas del Modelo:</strong><br>
            <span id="stats-content">Cargando...</span>
        </div>

        <!-- Panel de IA -->
        <div id="ai-panel" style="display: none;">
            <strong>🤖 Decisiones de la IA:</strong><br>
            <span id="ai-content">Analizando...</span>
        </div>

        <!-- Panel de controles -->
        <div id="controls-panel" style="display: none;">
            <strong>🎮 Controles del Modelo:</strong><br>
            <div class="control-group">
                <label>Escala: <span id="scale-value">1.0</span></label>
                <input type="range" id="scale-slider" class="control-slider" min="0.1" max="10" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Posición Y: <span id="posY-value">0.0</span></label>
                <input type="range" id="posY-slider" class="control-slider" min="-5" max="5" step="0.1" value="0.0">
            </div>
            <div class="control-group">
                <label>Rotación Y: <span id="rotY-value">0°</span></label>
                <input type="range" id="rotY-slider" class="control-slider" min="0" max="360" step="5" value="0">
            </div>
            <div class="control-group">
                <button class="btn btn-control" onclick="autoFitModel()">Auto Ajustar</button>
                <button class="btn btn-control" onclick="centerModel()">Centrar</button>
            </div>
        </div>

        <!-- Panel de debug -->
        <div id="debug-info" style="display: none;">
            <strong>🔍 Debug Info:</strong><br>
            Ruta: @ViewBag.ModeloPath<br>
            Estado: <span id="debug-status">Iniciando...</span><br>
            <div id="debug-details"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Variables globales
        let scene, camera, renderer, controls;
        let model, boundingBoxHelper, wireframeModels = [];
        const modelPath = '@ViewBag.ModeloPath';
        const modelId = '@ViewBag.ProductoId';
        const modelFile = '@ViewBag.ModeloArchivo';

        // Referencias DOM
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('error');
        const errorMessage = document.getElementById('error-message');
        const debugStatus = document.getElementById('debug-status');
        const debugDetails = document.getElementById('debug-details');
        const modelStats = document.getElementById('model-stats');
        const controlsPanel = document.getElementById('controls-panel');
        const statsContent = document.getElementById('stats-content');
        const aiPanel = document.getElementById('ai-panel');
        const aiContent = document.getElementById('ai-content');

        // 🤖 SISTEMA DE IA INTELIGENTE
        let aiAnalysis = null;
        let aiDecision = null;

        // Log inicial
        console.log('=== 🤖 IA AUTO-AJUSTE INICIADO ===');
        console.log('Producto ID:', modelId);
        console.log('Archivo Modelo:', modelFile);
        console.log('Ruta Modelo:', modelPath);

        // Función para actualizar debug
        function updateDebug(status, details = '') {
            if (debugStatus) debugStatus.textContent = status;
            if (details && debugDetails) {
                debugDetails.innerHTML = details;
            }
        }

        // Función para mostrar error
        function showError(message) {
            if (errorMessage) errorMessage.textContent = message;
            if (loadingElement) loadingElement.style.display = 'none';
            if (errorElement) errorElement.style.display = 'block';
            updateDebug('Error', message);
            console.error('🔴 ERROR:', message);
        }

        // Función para recargar modelo
        function recargarModelo() {
            if (errorElement) errorElement.style.display = 'none';
            if (loadingElement) loadingElement.style.display = 'block';

            // Limpiar modelo anterior
            if (model) {
                scene.remove(model);
                model = null;
            }
            if (boundingBoxHelper) {
                scene.remove(boundingBoxHelper);
                boundingBoxHelper = null;
            }
            wireframeModels.forEach(wf => scene.remove(wf));
            wireframeModels = [];

            // Ocultar paneles
            if (modelStats) modelStats.style.display = 'none';
            if (controlsPanel) controlsPanel.style.display = 'none';
            if (aiPanel) aiPanel.style.display = 'none';

            // Resetear variables de IA
            aiAnalysis = null;
            aiDecision = null;

            loadModel();
        }

        // Inicializar Three.js
        function init() {
            updateDebug('Inicializando Three.js');

            // Verificar que Three.js esté cargado
            if (typeof THREE === 'undefined') {
                showError('Three.js no se pudo cargar');
                return;
            }

            try {
                // Escena
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x333333);

                // Cámara
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
                camera.position.set(0, 2, 5);

                // Renderer
                const canvas = document.getElementById('canvas3d');
                if (!canvas) {
                    showError('Canvas no encontrado');
                    return;
                }

                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true
                });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;

                // Luces
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                const frontLight = new THREE.DirectionalLight(0xffffff, 0.4);
                frontLight.position.set(0, 0, 10);
                scene.add(frontLight);

                // Controles
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.minDistance = 0.1;
                    controls.maxDistance = 100;
                } else {
                    console.warn('OrbitControls no disponible');
                }

                // Eventos
                window.addEventListener('resize', onWindowResize);
                setupControlListeners();

                updateDebug('Three.js inicializado correctamente');
                loadModel();

            } catch (error) {
                console.error('Error inicializando Three.js:', error);
                showError('Error inicializando 3D: ' + error.message);
            }
        }

        // Configurar listeners de controles
        function setupControlListeners() {
            const scaleSlider = document.getElementById('scale-slider');
            const posYSlider = document.getElementById('posY-slider');
            const rotYSlider = document.getElementById('rotY-slider');

            if (!scaleSlider || !posYSlider || !rotYSlider) {
                console.warn('Algunos controles no se encontraron');
                return;
            }

            scaleSlider.addEventListener('input', function () {
                if (model) {
                    const scale = parseFloat(this.value);
                    model.scale.set(scale, scale, scale);
                    const scaleValue = document.getElementById('scale-value');
                    if (scaleValue) scaleValue.textContent = scale.toFixed(1);
                }
            });

            posYSlider.addEventListener('input', function () {
                if (model) {
                    const posY = parseFloat(this.value);
                    model.position.y = posY;
                    const posYValue = document.getElementById('posY-value');
                    if (posYValue) posYValue.textContent = posY.toFixed(1);
                }
            });

            rotYSlider.addEventListener('input', function () {
                if (model) {
                    const rotY = parseFloat(this.value) * Math.PI / 180;
                    model.rotation.y = rotY;
                    const rotYValue = document.getElementById('rotY-value');
                    if (rotYValue) rotYValue.textContent = this.value + '°';
                }
            });
        }

        // Cargar modelo
        function loadModel() {
            updateDebug('Cargando modelo GLB');
            console.log('=== INICIANDO CARGA DE MODELO ===');
            console.log('Ruta:', modelPath);

            // Verificar que GLTFLoader esté disponible
            if (typeof THREE.GLTFLoader === 'undefined') {
                showError('GLTFLoader no está disponible');
                return;
            }

            // Verificar que la ruta no esté vacía
            if (!modelPath || modelPath === '') {
                showError('Ruta del modelo no definida');
                return;
            }

            const loader = new THREE.GLTFLoader();

            loader.load(
                modelPath,
                function (gltf) {
                    try {
                        console.log('=== MODELO CARGADO EXITOSAMENTE ===');
                        console.log('GLTF Scene:', gltf.scene);

                        if (loadingElement) loadingElement.style.display = 'none';
                        updateDebug('Modelo cargado exitosamente');

                        model = gltf.scene;

                        // Verificar que el modelo no esté vacío
                        if (!model || model.children.length === 0) {
                            showError('El modelo está vacío o no contiene geometría');
                            return;
                        }

                        // Configurar sombras
                        model.traverse(function (node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });

                        scene.add(model);

                        // 🤖 ANÁLISIS DE IA - Con manejo de errores mejorado
                        try {
                            console.log('🤖 IA: Iniciando análisis...');
                            aiAnalysis = performAIAnalysis();
                            aiDecision = makeAIDecision(aiAnalysis);
                            updateAIPanel();

                            // Aplicar decisiones de IA AUTOMÁTICAMENTE
                            applyAIDecisions();

                            console.log('🤖 IA: Análisis completado exitosamente');
                        } catch (aiError) {
                            console.error('🔴 Error en análisis de IA:', aiError);
                            updateDebug('IA Error', aiError.message);
                            // Continuar sin IA si hay error
                        }

                        // Mostrar paneles de control
                        // Vista limpia - Solo mostrar el modelo 3D
                        if (modelStats) modelStats.style.display = 'none';
                        if (controlsPanel) controlsPanel.style.display = 'none';
                        if (aiPanel) aiPanel.style.display = 'none';
                        // Actualizar estadísticas en UI
                        analyzeModel();

                        updateDebug('✅ Modelo listo y optimizado');

                    } catch (loadError) {
                        console.error('Error procesando modelo cargado:', loadError);
                        showError('Error procesando modelo: ' + loadError.message);
                    }
                },
                function (xhr) {
                    if (xhr.lengthComputable) {
                        const percent = Math.floor((xhr.loaded / xhr.total) * 100);
                        if (loadingElement) loadingElement.textContent = `Cargando: ${percent}%`;
                        updateDebug('Cargando', `${percent}%`);
                    }
                },
                function (error) {
                    console.error('=== ERROR AL CARGAR MODELO ===');
                    console.error('Error completo:', error);

                    let errorMsg = 'Error desconocido';
                    if (error.message) {
                        errorMsg = error.message;
                    } else if (error.target && error.target.status) {
                        errorMsg = `HTTP ${error.target.status}: ${error.target.statusText}`;
                    }

                    showError(`Error de carga: ${errorMsg}`);
                }
            );
        }

        // 🤖 ANÁLISIS DE IA
        function performAIAnalysis() {
            if (!model) {
                throw new Error('Modelo no disponible para análisis');
            }

            console.log('🤖 IA: Iniciando análisis inteligente...');

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const centerDistance = center.length();

            let meshCount = 0;
            let vertexCount = 0;
            model.traverse(function (node) {
                if (node.isMesh) {
                    meshCount++;
                    if (node.geometry && node.geometry.attributes.position) {
                        vertexCount += node.geometry.attributes.position.count;
                    }
                }
            });

            return {
                filename: modelFile,
                dimensions: size,
                center: center,
                maxDim: maxDim,
                centerDistance: centerDistance,
                meshCount: meshCount,
                vertexCount: vertexCount,
                sizeCategory: classifySize(maxDim),
                centerCategory: classifyCenter(centerDistance),
                complexityCategory: classifyComplexity(vertexCount),
                problemCategory: classifyProblem(modelFile, center, maxDim)
            };
        }

        function classifySize(maxDim) {
            if (maxDim < 0.001) return 'microscopic';
            if (maxDim < 0.1) return 'tiny';
            if (maxDim < 1) return 'small';
            if (maxDim < 10) return 'normal';
            return 'large';
        }

        function classifyCenter(distance) {
            if (distance < 1) return 'origin';
            if (distance < 10) return 'near';
            if (distance < 50) return 'far';
            return 'extreme';
        }

        function classifyComplexity(vertices) {
            if (vertices < 1000) return 'simple';
            if (vertices < 10000) return 'moderate';
            if (vertices < 100000) return 'complex';
            return 'very_complex';
        }

        function classifyProblem(filename, center, maxDim) {
            // Basado en patrones conocidos
            if (filename && filename.includes('pizza3')) {
                return 'displaced_center_small';
            }
            if (filename && filename.includes('pizza4')) {
                return 'displaced_center_small';
            }
            if (filename && (filename.includes('pizza1') || filename.includes('pizza2'))) {
                return 'normal';
            }

            // Análisis general
            if (maxDim < 0.5 && center.length() > 10) {
                return 'displaced_center_small';
            }

            return 'unknown';
        }

        // 🤖 DECISIONES DE IA
        function makeAIDecision(analysis) {
            console.log('🤖 IA: Tomando decisiones inteligentes...');

            let decision = {
                strategy: 'standard',
                scale: 1.0,
                rotationY: 0,
                positionY: 0.0,
                centerCorrection: false,
                noAutoRotation: false,
                reasoning: []
            };

            if (analysis.problemCategory === 'displaced_center_small') {
                decision.strategy = 'displaced_small_fix';
                decision.centerCorrection = true;
                decision.reasoning.push('Centro desplazado detectado');

                if (analysis.maxDim < 0.5) {
                    decision.scale = 20.0;
                    decision.reasoning.push('Modelo muy pequeño: escala agresiva aplicada');
                } else {
                    decision.scale = 8.0;
                    decision.reasoning.push('Modelo pequeño: escala moderada aplicada');
                }

                if (analysis.filename && analysis.filename.includes('pizza3')) {
                    decision.rotationY = 50;
                    decision.reasoning.push('pizza3: rotación óptima aplicada');
                } else if (analysis.filename && analysis.filename.includes('pizza4')) {
                    decision.rotationY = 45;
                    decision.reasoning.push('pizza4: rotación óptima aplicada');
                }

            } else if (analysis.problemCategory === 'normal') {
                decision.strategy = 'standard_optimize';
                decision.scale = Math.max(4.0 / Math.max(analysis.maxDim, 0.1), 1.0);
                decision.reasoning.push('Modelo normal: optimización estándar');
                decision.noAutoRotation = true;

            } else {
                // Análisis general para casos desconocidos
                if (analysis.sizeCategory === 'tiny' || analysis.sizeCategory === 'microscopic') {
                    decision.scale = 25.0;
                    decision.reasoning.push('Tamaño microscópico: amplificación extrema');
                } else if (analysis.centerCategory === 'far' || analysis.centerCategory === 'extreme') {
                    decision.centerCorrection = true;
                    decision.scale = 7.0;
                    decision.reasoning.push('Centro lejano: corrección + amplificación');
                } else {
                    // Escala basada en tamaño
                    decision.scale = Math.max(3.0 / Math.max(analysis.maxDim, 0.1), 0.5);
                    decision.reasoning.push('Ajuste automático de escala');
                }
            }

            decision.reasoning.push(`Estrategia final: ${decision.strategy}`);
            return decision;
        }

        // 🤖 APLICAR DECISIONES DE IA AUTOMÁTICAMENTE
        function applyAIDecisions() {
            if (!model || !aiDecision) {
                console.warn('🤖 IA: No se pueden aplicar decisiones - modelo o decisión faltante');
                return;
            }

            console.log('🤖 IA: Aplicando decisiones automáticamente...');

            try {
                // 1. Corrección de centro si es necesaria
                if (aiDecision.centerCorrection && aiAnalysis) {
                    const center = aiAnalysis.center;
                    model.position.copy(center).negate();
                    console.log('🤖 IA: Centro corregido');
                }

                // 2. Aplicar escala decidida por IA
                model.scale.set(aiDecision.scale, aiDecision.scale, aiDecision.scale);
                console.log('🤖 IA: Escala aplicada:', aiDecision.scale);

                // 3. Aplicar rotación decidida por IA
                const rotRad = (aiDecision.rotationY * Math.PI) / 180;
                model.rotation.y = rotRad;
                console.log('🤖 IA: Rotación aplicada:', aiDecision.rotationY);

                // 4. Posición Y
                model.position.y = aiDecision.positionY;

                // 5. Ajuste final sobre el suelo
                const finalBox = new THREE.Box3().setFromObject(model);
                if (finalBox.min.y < 0) {
                    model.position.y = -(finalBox.min.y) + 0.1;
                }

                // 6. Actualizar controles UI para reflejar los valores aplicados
                const scaleSlider = document.getElementById('scale-slider');
                const scaleValue = document.getElementById('scale-value');
                const posYSlider = document.getElementById('posY-slider');
                const posYValue = document.getElementById('posY-value');
                const rotYSlider = document.getElementById('rotY-slider');
                const rotYValue = document.getElementById('rotY-value');

                if (scaleSlider) scaleSlider.value = aiDecision.scale;
                if (scaleValue) scaleValue.textContent = aiDecision.scale.toFixed(1);
                if (posYSlider) posYSlider.value = model.position.y;
                if (posYValue) posYValue.textContent = model.position.y.toFixed(1);
                if (rotYSlider) rotYSlider.value = aiDecision.rotationY;
                if (rotYValue) rotYValue.textContent = aiDecision.rotationY + '°';

                // 7. Ajustar cámara
                fitCameraToModel();

                console.log('🤖 IA: Todas las decisiones aplicadas automáticamente');

            } catch (error) {
                console.error('🔴 Error aplicando decisiones de IA:', error);
                updateDebug('Error IA', 'Error aplicando decisiones: ' + error.message);
            }
        }

        function updateAIPanel() {
            if (!aiAnalysis || !aiDecision || !aiContent) return;

            try {
                aiContent.innerHTML = `
                            <div class="ai-decision">Estrategia: ${aiDecision.strategy}</div>
                            <div class="ai-decision">Escala IA: ${aiDecision.scale}x</div>
                            <div class="ai-decision">Rotación IA: ${aiDecision.rotationY}°</div>
                            <div class="ai-decision">Centro: ${aiDecision.centerCorrection ? 'Corregido' : 'Original'}</div>
                            <br>
                            <div class="ai-reasoning">Razonamiento IA:</div>
                            ${aiDecision.reasoning.map(r => `<div class="ai-reasoning">• ${r}</div>`).join('')}
                            <br>
                            <div style="color: #ffff99; font-size: 10px;">
                            Análisis: ${aiAnalysis.sizeCategory}, ${aiAnalysis.centerCategory}, ${aiAnalysis.problemCategory}
                            </div>
                        `;
            } catch (error) {
                console.error('Error actualizando panel de IA:', error);
                if (aiContent) aiContent.innerHTML = '<div style="color: red;">Error mostrando análisis de IA</div>';
            }
        }

        // Analizar modelo en detalle
        function analyzeModel() {
            if (!model || !statsContent) return;

            try {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                let meshCount = 0;
                let materialCount = 0;
                let vertexCount = 0;

                model.traverse(function (node) {
                    if (node.isMesh) {
                        meshCount++;
                        if (node.material) materialCount++;
                        if (node.geometry && node.geometry.attributes.position) {
                            vertexCount += node.geometry.attributes.position.count;
                        }
                    }
                });

                const maxDim = Math.max(size.x, size.y, size.z);

                statsContent.innerHTML = `
                            <strong>Archivo:</strong> ${modelFile}<br>
                            <strong>Dimensiones:</strong> ${size.x.toFixed(3)} × ${size.y.toFixed(3)} × ${size.z.toFixed(3)}<br>
                            <strong>Centro:</strong> (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})<br>
                            <strong>Dim. máxima:</strong> ${maxDim.toFixed(3)}<br>
                            <strong>Meshes:</strong> ${meshCount}<br>
                            <strong>Materiales:</strong> ${materialCount}<br>
                            <strong>Vértices:</strong> ${vertexCount}
                        `;

                // Diagnosticar problemas potenciales
                let warnings = [];
                if (maxDim < 0.01) warnings.push('⚠️ Modelo muy pequeño');
                if (maxDim > 50) warnings.push('⚠️ Modelo muy grande');
                if (Math.abs(center.x) > 10 || Math.abs(center.y) > 10 || Math.abs(center.z) > 10)
                    warnings.push('⚠️ Centro lejos del origen');
                if (meshCount === 0) warnings.push('❌ Sin meshes');

                if (warnings.length > 0) {
                    statsContent.innerHTML += '<br><strong>Advertencias:</strong><br>' + warnings.join('<br>');
                }

            } catch (error) {
                console.error('Error analizando modelo:', error);
                statsContent.innerHTML = '<div style="color: red;">Error analizando modelo</div>';
            }
        }

        // Auto ajustar modelo a la vista
        function autoFitModel() {
            if (!model) return;

            try {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                // Calcular escala apropiada
                let targetScale = 1;
                if (maxDim > 0) {
                    targetScale = 3 / maxDim; // Hacer que el modelo ocupe ~3 unidades
                }

                // Aplicar ajustes
                model.scale.set(targetScale, targetScale, targetScale);
                model.position.copy(center).negate(); // Centrar en origen

                // Actualizar controles
                const scaleSlider = document.getElementById('scale-slider');
                const scaleValue = document.getElementById('scale-value');
                const posYSlider = document.getElementById('posY-slider');
                const posYValue = document.getElementById('posY-value');

                if (scaleSlider) scaleSlider.value = targetScale;
                if (scaleValue) scaleValue.textContent = targetScale.toFixed(1);
                if (posYSlider) posYSlider.value = 0;
                if (posYValue) posYValue.textContent = '0.0';

                // Ajustar cámara
                fitCameraToModel();

                console.log('Modelo auto-ajustado. Escala:', targetScale);
            } catch (error) {
                console.error('Error en auto-ajuste:', error);
            }
        }

        // Centrar modelo
        function centerModel() {
            if (!model) return;

            try {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.copy(center).negate();

                const posYSlider = document.getElementById('posY-slider');
                const posYValue = document.getElementById('posY-value');

                if (posYSlider) posYSlider.value = 0;
                if (posYValue) posYValue.textContent = '0.0';
            } catch (error) {
                console.error('Error centrando modelo:', error);
            }
        }

        // Resetear cámara
        function resetCamera() {
            if (!camera || !controls) return;

            try {
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
            } catch (error) {
                console.error('Error reseteando cámara:', error);
            }
        }

        // Toggle wireframe
        function toggleWireframe() {
            if (!model) return;

            try {
                if (wireframeModels.length > 0) {
                    // Remover wireframes
                    wireframeModels.forEach(wf => scene.remove(wf));
                    wireframeModels = [];
                } else {
                    // Crear wireframes
                    model.traverse(function (node) {
                        if (node.isMesh && node.geometry) {
                            const wireframe = new THREE.WireframeGeometry(node.geometry);
                            const line = new THREE.LineSegments(wireframe);
                            line.material.color.setHex(0x00ff00);
                            line.position.copy(node.position);
                            line.rotation.copy(node.rotation);
                            line.scale.copy(node.scale);
                            scene.add(line);
                            wireframeModels.push(line);
                        }
                    });
                }
            } catch (error) {
                console.error('Error con wireframe:', error);
            }
        }

        // Mostrar bounding box
        function showBoundingBox() {
            if (!model) return;

            try {
                if (boundingBoxHelper) {
                    scene.remove(boundingBoxHelper);
                    boundingBoxHelper = null;
                } else {
                    const box = new THREE.Box3().setFromObject(model);
                    boundingBoxHelper = new THREE.Box3Helper(box, 0xff0000);
                    scene.add(boundingBoxHelper);
                }
            } catch (error) {
                console.error('Error con bounding box:', error);
            }
        }

        // Ajustar cámara al modelo
        function fitCameraToModel() {
            if (!model || !camera || !controls) return;

            try {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
                cameraZ *= 2; // Factor de seguridad

                camera.position.set(center.x, center.y + (size.y / 4), center.z + cameraZ);
                controls.target.copy(center);
                controls.update();
            } catch (error) {
                console.error('Error ajustando cámara:', error);
            }
        }

        // Manejar redimensionamiento
        function onWindowResize() {
            if (!camera || !renderer) return;

            try {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            } catch (error) {
                console.error('Error en resize:', error);
            }
        }

        // Función de animación
        function animate() {
            requestAnimationFrame(animate);

            try {
                if (controls) {
                    controls.update();
                }

                // 🤖 IA: Rotación automática inteligente
                // Solo rotar si NO es un modelo normal Y el slider está en 0
                const rotYSlider = document.getElementById('rotY-slider');
                const shouldAutoRotate = aiDecision && !aiDecision.noAutoRotation;

                if (model && rotYSlider && rotYSlider.value == 0 && shouldAutoRotate) {
                    model.rotation.y += 0.003;
                }

                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('Error en animación:', error);
            }
        }

        // Configuración de visibilidad de paneles
        const PANEL_CONFIG = {
            showStats: false,      // Panel de estadísticas (izquierda arriba)
            showAI: false,         // Panel de IA (izquierda medio)
            showControls: false,   // Panel de controles (izquierda abajo)
            showDebug: false       // Panel de debug (derecha arriba)
        };

        // Función para aplicar configuración de paneles
        function applyPanelConfiguration() {
            // Ocultar/mostrar paneles según configuración
            if (modelStats) {
                modelStats.style.display = PANEL_CONFIG.showStats ? 'block' : 'none';
            }

            if (aiPanel) {
                aiPanel.style.display = PANEL_CONFIG.showAI ? 'block' : 'none';
            }

            if (controlsPanel) {
                controlsPanel.style.display = PANEL_CONFIG.showControls ? 'block' : 'none';
            }

            if (debugInfo) {
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo) {
                    debugInfo.style.display = PANEL_CONFIG.showDebug ? 'block' : 'none';
                }
            }

            console.log('🎯 Configuración de paneles aplicada - Vista limpia activada');
        }


        // Iniciar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', function () {
            console.log('=== 🤖 INICIO DE IA AUTO-AJUSTE ===');
            console.log('DOM cargado, iniciando aplicación...');

            // Pequeño delay para asegurar que las librerías estén cargadas
            setTimeout(function () {
                init();
                animate();
            }, 100);
        });

        // Manejo de errores globales
        window.addEventListener('error', function (e) {
            console.error('🔴 Error global capturado:', e.error);
            updateDebug('Error Global', e.message);
        });

    </script>
</body>
</html>